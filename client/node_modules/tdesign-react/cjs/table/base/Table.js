/**
 * tdesign v0.22.1
 * (c) 2022 tdesign
 * @license MIT
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var defineProperty = require('../../_chunks/dep-449daca3.js');
var slicedToArray = require('../../_chunks/dep-fa36e79f.js');
var React = require('react');
var classNames = require('classnames');
var debounce$1 = require('../../_chunks/dep-228a3548.js');
var isObject$1 = require('../../_chunks/dep-735b841a.js');
var _util_useUpdateEffect = require('../../_util/useUpdateEffect.js');
var _util_useConfig = require('../../_util/useConfig.js');
var pagination_index = require('../../pagination/index.js');
var table_hooks_useColumns = require('../hooks/useColumns.js');
var table_util_index = require('../util/index.js');
var table_base_TableEmptyBody = require('./TableEmptyBody.js');
var table_base_TableHeader = require('./TableHeader.js');
var table_base_TableBody = require('./TableBody.js');
var table_base_TableLoadingBody = require('./TableLoadingBody.js');
var table_base_TableAsyncLoadingBody = require('./TableAsyncLoadingBody.js');
var table_base_TableContext = require('./TableContext.js');
var table_base_TableColGroup = require('./TableColGroup.js');
var table_base_TableFooter = require('./TableFooter.js');
var loading_index = require('../../loading/index.js');
require('../../_chunks/dep-045b87c1.js');
require('../../_chunks/dep-0e3f1753.js');
require('../../_chunks/dep-a7666a95.js');
require('../../_chunks/dep-8bb9b7ba.js');
require('../../_chunks/dep-9c74d22d.js');
require('../../_chunks/dep-48870ae5.js');
require('../../config-provider/ConfigContext.js');
require('../../locale/zh_CN.js');
require('../../pagination/Pagination.js');
require('tdesign-icons-react');
require('../../_util/noop.js');
require('../../_util/useDefault.js');
require('../../select/index.js');
require('../../select/base/Select.js');
require('../../_chunks/dep-1bafebb1.js');
require('../../_chunks/dep-af921283.js');
require('../../_chunks/dep-4f605641.js');
require('../../_chunks/dep-9125a75e.js');
require('../../_chunks/dep-20e76bfc.js');
require('../../_chunks/dep-6681bc7b.js');
require('../../_chunks/dep-7a0cfc4c.js');
require('../../_chunks/dep-0705da20.js');
require('lodash');
require('../../locale/LocalReceiver.js');
require('../../_util/composeRefs.js');
require('../../_util/useDefaultValue.js');
require('../../_chunks/dep-e03ca79d.js');
require('../../_util/forwardRefWithStatics.js');
require('hoist-non-react-statics');
require('../../select/util/helper.js');
require('../../_chunks/dep-8f3deb2a.js');
require('../../select/base/OptionGroup.js');
require('../../select/base/Option.js');
require('../../_chunks/dep-f0639562.js');
require('../../_util/useRipple.js');
require('../../_util/setStyle.js');
require('../../common/FakeArrow.js');
require('../../input/index.js');
require('../../input/Input.js');
require('../../input/InputGroup.js');
require('../../popup/index.js');
require('../../popup/Popup.js');
require('react-transition-group');
require('react-popper');
require('../../_util/usePrevious.js');
require('../../popup/Portal.js');
require('react-dom');
require('../../popup/hooks/useTriggerProps.js');
require('../../_util/useClickOutside.js');
require('../../popup/hooks/usePopupCssTransition.js');
require('../../tag/index.js');
require('../../tag/Tag.js');
require('../../tag/CheckTag.js');
require('../../select/base/PopupContent.js');
require('../../loading/loading.js');
require('../../_util/dom.js');
require('raf');
require('../../_util/easing.js');
require('../../common/Portal.js');
require('../../loading/gradient.js');
require('../../loading/plugin.js');
require('../../input-number/index.js');
require('../../input-number/InputNumber.js');
require('../../_util/useCommonClassName.js');
require('../../input-number/StepHandler.js');
require('../../button/index.js');
require('../../button/Button.js');
require('../../input-number/utils/numberUtils.js');
require('../../pagination/validators.js');
require('./TableCell.js');
require('./TableRow.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var classNames__default = /*#__PURE__*/_interopDefaultLegacy(classNames);

var debounce = debounce$1.debounce_1,
    isObject = isObject$1.isObject_1;
/** Error message constants. */

var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */

function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

var throttle_1 = throttle;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { defineProperty._defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function BaseTable(props) {
  var _classNames, _classNames2;

  var _useConfig = _util_useConfig["default"](),
      classPrefix = _useConfig.classPrefix;

  var _props$bordered = props.bordered,
      bordered = _props$bordered === void 0 ? false : _props$bordered,
      _props$stripe = props.stripe,
      stripe = _props$stripe === void 0 ? false : _props$stripe,
      _props$hover = props.hover,
      hover = _props$hover === void 0 ? false : _props$hover,
      _props$tableLayout = props.tableLayout,
      tableLayout = _props$tableLayout === void 0 ? "fixed" : _props$tableLayout,
      _props$verticalAlign = props.verticalAlign,
      verticalAlign = _props$verticalAlign === void 0 ? "center" : _props$verticalAlign,
      _props$size = props.size,
      size = _props$size === void 0 ? "medium" : _props$size,
      maxHeight = props.maxHeight,
      height = props.height,
      loading = props.loading,
      empty = props.empty,
      _props$data = props.data,
      data = _props$data === void 0 ? [] : _props$data,
      pagination = props.pagination,
      onPageChange = props.onPageChange,
      onScrollX = props.onScrollX,
      onScrollY = props.onScrollY,
      asyncLoading = props.asyncLoading;

  var _useColumns = table_hooks_useColumns.useColumns(props),
      _useColumns2 = slicedToArray._slicedToArray(_useColumns, 2),
      columns = _useColumns2[0],
      flattenColumns = _useColumns2[1];

  var hasPagination = false;

  var _useState = React.useState((pagination === null || pagination === void 0 ? void 0 : pagination.current) || (pagination === null || pagination === void 0 ? void 0 : pagination.defaultCurrent) || 1),
      _useState2 = slicedToArray._slicedToArray(_useState, 2),
      innerCurrent = _useState2[0],
      setInnerCurrentPagination = _useState2[1];

  var _useState3 = React.useState((pagination === null || pagination === void 0 ? void 0 : pagination.pageSize) || (pagination === null || pagination === void 0 ? void 0 : pagination.defaultPageSize) || 10),
      _useState4 = slicedToArray._slicedToArray(_useState3, 2),
      innerPageSize = _useState4[0],
      setInnerPageSize = _useState4[1];

  var isControlledPagination = typeof (pagination === null || pagination === void 0 ? void 0 : pagination.current) !== "undefined" && typeof (pagination === null || pagination === void 0 ? void 0 : pagination.pageSize) !== "undefined";
  _util_useUpdateEffect["default"](function () {
    if (isControlledPagination) {
      setInnerCurrentPagination(pagination === null || pagination === void 0 ? void 0 : pagination.current);
      setInnerPageSize(pagination === null || pagination === void 0 ? void 0 : pagination.pageSize);
    }
  }, [pagination]);

  var onPageSizeChange = function onPageSizeChange(pageSize, pageInfo) {
    var _pagination$onPageSiz;

    pagination === null || pagination === void 0 ? void 0 : (_pagination$onPageSiz = pagination.onPageSizeChange) === null || _pagination$onPageSiz === void 0 ? void 0 : _pagination$onPageSiz.call(pagination, pageSize, pageInfo);
  };

  if (pagination) {
    var total = pagination.total,
        showJumper = pagination.showJumper;
    hasPagination = total > innerPageSize || showJumper && total <= innerPageSize;
  }

  var onInnerPaginationChange = function onInnerPaginationChange(pageInfo) {
    var _pagination$onChange;

    var current = pageInfo.current,
        pageSize = pageInfo.pageSize;
    var newDataSource = data.slice((current - 1) * pageSize, current * pageSize);
    onPageChange === null || onPageChange === void 0 ? void 0 : onPageChange(pageInfo, newDataSource);
    pagination === null || pagination === void 0 ? void 0 : (_pagination$onChange = pagination.onChange) === null || _pagination$onChange === void 0 ? void 0 : _pagination$onChange.call(pagination, pageInfo);

    if (!isControlledPagination) {
      setInnerCurrentPagination(current);
      setInnerPageSize(pageSize);
    }
  };

  var pageData = React.useMemo(function () {
    if (!hasPagination) return data;

    if (data.length > innerPageSize) {
      var pageStart = (innerCurrent - 1) * innerPageSize;
      var pageEnd = innerCurrent * innerPageSize;
      return data.slice(pageStart, pageEnd);
    }

    return data;
  }, [data, innerPageSize, hasPagination, innerCurrent]);

  var _useState5 = React.useState(0),
      _useState6 = slicedToArray._slicedToArray(_useState5, 2),
      scrollBarWidth = _useState6[0],
      setScrollBarWidth = _useState6[1];

  var fixedHeader = height > 0 || maxHeight > 0;
  var table = React.useMemo(function () {
    return {
      fixedHeader: fixedHeader,
      flattenColumns: flattenColumns
    };
  }, [fixedHeader, flattenColumns]);
  var hasFixedColumns = columns.some(function (_ref) {
    var fixed = _ref.fixed;
    return ["left", "right"].includes(fixed);
  });
  var scrollHeaderRef = React.useRef();
  var scrollBodyRef = React.useRef();
  var tableRef = React.useRef();
  var tableContentRef = React.useRef();

  var _useState7 = React.useState(false),
      _useState8 = slicedToArray._slicedToArray(_useState7, 2),
      scrollableToLeft = _useState8[0],
      setScrollableToLeft = _useState8[1];

  var _useState9 = React.useState(false),
      _useState10 = slicedToArray._slicedToArray(_useState9, 2),
      scrollableToRight = _useState10[0],
      setScrollableToRight = _useState10[1];

  var _useState11 = React.useState(false),
      _useState12 = slicedToArray._slicedToArray(_useState11, 2),
      isHasScrollbar = _useState12[0],
      setIsHasScrollbar = _useState12[1];

  React.useLayoutEffect(function () {
    if (fixedHeader) {
      setStateScrollBarWidth();
    }
  }, [fixedHeader]);
  React.useLayoutEffect(function () {
    if (fixedHeader) {
      var limitHeight = height || maxHeight;
      var tableNode = tableRef.current;
      var isHasScrollbarNew = tableNode.offsetHeight > limitHeight;
      setIsHasScrollbar(isHasScrollbarNew);
    }
  }, [pageData]);
  React.useLayoutEffect(function () {
    var checkScrollableToLeftOrRightDebounce;

    if (hasFixedColumns) {
      checkScrollableToLeftOrRight();
      checkScrollableToLeftOrRightDebounce = debounce$1.debounce_1(checkScrollableToLeftOrRight);
      window.addEventListener("resize", checkScrollableToLeftOrRightDebounce);
    }

    return function () {
      if (hasFixedColumns) {
        window.removeEventListener("resize", checkScrollableToLeftOrRightDebounce);
      }
    };
  }, [hasFixedColumns]);
  var isEmpty = !data.length;

  function renderTableBodyAndTableFooter() {
    if (!!loading) {
      return isEmpty ? /* @__PURE__ */React__default["default"].createElement(table_base_TableFooter["default"], null, /* @__PURE__ */React__default["default"].createElement(table_base_TableEmptyBody["default"], {
        empty: null
      })) : /* @__PURE__ */React__default["default"].createElement(table_base_TableBody["default"], _objectSpread(_objectSpread({}, props), {}, {
        data: pageData
      }));
    }

    if (!!asyncLoading) {
      return /* @__PURE__ */React__default["default"].createElement(React__default["default"].Fragment, null, /* @__PURE__ */React__default["default"].createElement(table_base_TableBody["default"], _objectSpread(_objectSpread({}, props), {}, {
        data: pageData
      })), /* @__PURE__ */React__default["default"].createElement(table_base_TableFooter["default"], {
        colspan: columns.length
      }, /* @__PURE__ */React__default["default"].createElement(table_base_TableAsyncLoadingBody["default"], _objectSpread({}, props))));
    }

    if (isEmpty) {
      return /* @__PURE__ */React__default["default"].createElement(table_base_TableFooter["default"], null, /* @__PURE__ */React__default["default"].createElement(table_base_TableEmptyBody["default"], {
        empty: empty
      }));
    }

    return /* @__PURE__ */React__default["default"].createElement(table_base_TableBody["default"], _objectSpread(_objectSpread({}, props), {}, {
      data: pageData
    }));
  }

  var paginationNode;

  if (hasPagination) {
    paginationNode = /* @__PURE__ */React__default["default"].createElement("div", {
      className: "".concat(classPrefix, "-table__pagination")
    }, /* @__PURE__ */React__default["default"].createElement(pagination_index.Pagination, _objectSpread(_objectSpread({}, pagination), {}, {
      current: innerCurrent,
      pageSize: innerPageSize,
      onChange: onInnerPaginationChange,
      onPageSizeChange: onPageSizeChange
    })));
  }

  function getTable(params) {
    var _ref2 = params || {},
        _ref2$enableHeader = _ref2.enableHeader,
        enableHeader = _ref2$enableHeader === void 0 ? true : _ref2$enableHeader,
        _ref2$enableBody = _ref2.enableBody,
        enableBody = _ref2$enableBody === void 0 ? true : _ref2$enableBody;

    return /* @__PURE__ */React__default["default"].createElement("table", {
      ref: tableRef,
      style: {
        tableLayout: tableLayout,
        height: "100%"
      }
    }, /* @__PURE__ */React__default["default"].createElement(table_base_TableColGroup.TableColGroup, {
      columns: columns
    }), enableHeader ? /* @__PURE__ */React__default["default"].createElement(table_base_TableHeader["default"], {
      columns: columns
    }) : null, enableBody ? renderTableBodyAndTableFooter() : null);
  }

  function getTableWithFixedHeader() {
    var style = {};

    if (isHasScrollbar) {
      style = _objectSpread(_objectSpread({}, style), {}, {
        paddingRight: scrollBarWidth
      });
    }

    var fixedHeaderRN = /* @__PURE__ */React__default["default"].createElement("div", {
      ref: scrollHeaderRef,
      className: "".concat(classPrefix, "-table__header"),
      style: style
    }, getTable({
      enableBody: false
    }));

    var onScroll = function onScroll(e) {
      var scrollLeft = e.target.scrollLeft;
      scrollHeaderRef.current.scrollLeft = scrollLeft;
      handleScroll(e, 10);
    };

    var fixedBodyRN = /* @__PURE__ */React__default["default"].createElement("div", _objectSpread({
      ref: scrollBodyRef,
      className: "".concat(classPrefix, "-table__body"),
      style: {
        height: isNaN(Number(height)) ? height : "".concat(Number(height), "px"),
        maxHeight: isNaN(Number(maxHeight)) ? maxHeight : "".concat(Number(maxHeight), "px"),
        width: hasFixedColumns ? "100%" : void 0
      }
    }, hasFixedColumns ? {
      onScroll: onScroll
    } : {}), getTable({
      enableHeader: false
    }));
    return /* @__PURE__ */React__default["default"].createElement(React__default["default"].Fragment, null, fixedHeaderRN, fixedBodyRN);
  }

  function setStateScrollBarWidth() {
    var scrollDiv = document.createElement("div");
    scrollDiv.style.cssText = "\n      width: 99px;\n      height: 99px;\n      overflow: scroll;\n      position: absolute;\n      top: -9999px;";
    scrollDiv.classList.add("scrollbar");
    document.body.appendChild(scrollDiv);
    var scrollBarWidth2 = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    setScrollBarWidth(scrollBarWidth2);
    document.body.removeChild(scrollDiv);
  }

  function checkScrollableToLeftOrRight() {
    var scrollContainer = fixedHeader ? scrollBodyRef.current : tableContentRef.current;
    var scrollLeft = scrollContainer.scrollLeft,
        scrollWidth = scrollContainer.scrollWidth,
        clientWidth = scrollContainer.clientWidth;
    var scrollableToLeft2 = scrollLeft > 0;
    setScrollableToLeft(scrollableToLeft2);
    var scrollableToRight2 = scrollLeft + clientWidth < scrollWidth;
    setScrollableToRight(scrollableToRight2);
  }

  function handleScroll(e) {
    var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
    var _e$target = e.target,
        scrollLeft = _e$target.scrollLeft,
        scrollTop = _e$target.scrollTop;
    var scrollFn = throttle_1(function () {
      checkScrollableToLeftOrRight();
      var direction = table_util_index.getScrollDirection(scrollLeft, scrollTop);

      if (direction !== table_util_index.ScrollDirection.UNKNOWN) {
        var scrollListenerFn = direction === table_util_index.ScrollDirection.X ? onScrollX : onScrollY;
        var scrollParams = {
          e: e
        };
        scrollListenerFn === null || scrollListenerFn === void 0 ? void 0 : scrollListenerFn(scrollParams);
      }
    }, duration);
    scrollFn();
  }

  return /* @__PURE__ */React__default["default"].createElement("div", {
    className: classNames__default["default"]("".concat(classPrefix, "-table"), (_classNames = {}, defineProperty._defineProperty(_classNames, "".concat(classPrefix, "-table--striped"), stripe), defineProperty._defineProperty(_classNames, "".concat(classPrefix, "-table--bordered"), bordered), defineProperty._defineProperty(_classNames, "".concat(classPrefix, "-size-l"), size === "large"), defineProperty._defineProperty(_classNames, "".concat(classPrefix, "-size-s"), size === "small"), defineProperty._defineProperty(_classNames, "".concat(classPrefix, "-table--hoverable"), hover), defineProperty._defineProperty(_classNames, "".concat(classPrefix, "-table--align-").concat(verticalAlign), verticalAlign), defineProperty._defineProperty(_classNames, "".concat(classPrefix, "-table__header--fixed"), fixedHeader), defineProperty._defineProperty(_classNames, "".concat(classPrefix, "-table__cell--fixed ").concat(classPrefix, "-table--has-fixed"), hasFixedColumns), _classNames))
  }, /* @__PURE__ */React__default["default"].createElement(table_base_TableContext.TableContextProvider, {
    value: table
  }, /* @__PURE__ */React__default["default"].createElement(loading_index.Loading, {
    loading: !!loading,
    showOverlay: true,
    indicator: loading === true,
    text: typeof loading !== "boolean" ? /* @__PURE__ */React__default["default"].createElement(table_base_TableLoadingBody["default"], _objectSpread({}, props)) : null
  }, /* @__PURE__ */React__default["default"].createElement("div", _objectSpread({
    ref: tableContentRef,
    className: classNames__default["default"]("".concat(classPrefix, "-table__content"), (_classNames2 = {}, defineProperty._defineProperty(_classNames2, "".concat(classPrefix, "-table__content--scrollable-to-right"), scrollableToRight), defineProperty._defineProperty(_classNames2, "".concat(classPrefix, "-table__content--scrollable-to-left"), scrollableToLeft), _classNames2)),
    style: {
      overflow: "auto"
    }
  }, hasFixedColumns ? {
    onScroll: handleScroll
  } : {}), !fixedHeader ? getTable() : getTableWithFixedHeader())), hasPagination && paginationNode));
}

exports["default"] = BaseTable;
//# sourceMappingURL=Table.js.map
