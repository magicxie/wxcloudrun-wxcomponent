/**
 * tdesign v0.22.1
 * (c) 2022 tdesign
 * @license MIT
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var toConsumableArray = require('../_chunks/dep-8f3deb2a.js');
var index = require('../_chunks/dep-b000fdae.js');
var defineProperty = require('../_chunks/dep-449daca3.js');
var slicedToArray = require('../_chunks/dep-fa36e79f.js');
var React = require('react');
var isEmpty = require('../_chunks/dep-72f8673c.js');
var _cacheHas = require('../_chunks/dep-66fbd01b.js');
var _typeof = require('../_chunks/dep-a7666a95.js');
var _Uint8Array = require('../_chunks/dep-c57ef5b6.js');
var _baseGetTag = require('../_chunks/dep-0e3f1753.js');
var eq$1 = require('../_chunks/dep-6681bc7b.js');
var _getTag = require('../_chunks/dep-c82d4aac.js');
var isArray$2 = require('../_chunks/dep-9125a75e.js');
var isObjectLike$1 = require('../_chunks/dep-48870ae5.js');
var isObject$1 = require('../_chunks/dep-735b841a.js');
var get$1 = require('../_chunks/dep-af921283.js');
var hasIn$1 = require('../_chunks/dep-59b9b071.js');
var _baseGet = require('../_chunks/dep-4f605641.js');
var identity$1 = require('../_chunks/dep-4a02b995.js');
var _baseProperty = require('../_chunks/dep-942a7aba.js');
var toInteger$1 = require('../_chunks/dep-5e46865d.js');
var dialog_index = require('../dialog/index.js');
var upload_dragger = require('./dragger.js');
var upload_uploadTrigger = require('./upload-trigger.js');
var upload_tips = require('./tips.js');
var _common_js_upload_xhr = require('../_common/js/upload/xhr.js');
var _util_useConfig = require('../_util/useConfig.js');
var upload_themes_singleFile = require('./themes/single-file.js');
var upload_themes_imageCard = require('./themes/image-card.js');
var upload_themes_flowList_index = require('./themes/flow-list/index.js');
var upload_booleanRender = require('./boolean-render.js');
var upload_util = require('./util.js');
var upload_hooks_useDefaultValue = require('./hooks/useDefaultValue.js');
require('../_chunks/dep-045b87c1.js');
require('../_chunks/dep-c5449fbe.js');
require('../_chunks/dep-f445e9bb.js');
require('../_chunks/dep-1bafebb1.js');
require('../_chunks/dep-72511bfe.js');
require('../_chunks/dep-20e76bfc.js');
require('../_chunks/dep-7d00ab60.js');
require('../_chunks/dep-07d4a79b.js');
require('../_chunks/dep-fb89215e.js');
require('../_chunks/dep-69abf228.js');
require('../_chunks/dep-9c74d22d.js');
require('../_chunks/dep-7a0cfc4c.js');
require('../_chunks/dep-8bb9b7ba.js');
require('../dialog/Dialog.js');
require('../_chunks/dep-e03ca79d.js');
require('../_chunks/dep-0705da20.js');
require('tdesign-icons-react');
require('../locale/LocalReceiver.js');
require('../config-provider/ConfigContext.js');
require('../locale/zh_CN.js');
require('../button/index.js');
require('../button/Button.js');
require('classnames');
require('../_util/noop.js');
require('../_util/useRipple.js');
require('../_util/setStyle.js');
require('../loading/index.js');
require('../loading/loading.js');
require('../_util/dom.js');
require('raf');
require('../_util/easing.js');
require('../common/Portal.js');
require('react-dom');
require('../loading/gradient.js');
require('../loading/plugin.js');
require('../dialog/RenderDialog.js');
require('react-transition-group');
require('../_util/useSetState.js');
require('../dialog/plugin.js');
require('./themes/dragger-progress.js');
require('./themes/flow-list/img-list.js');
require('./themes/flow-list/file-list.js');
require('../_util/useDefault.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */

function arraySome$1(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }

  return false;
}

var _arraySome = arraySome$1;

var SetCache = _cacheHas._SetCache,
    arraySome = _arraySome,
    cacheHas = _cacheHas._cacheHas;
/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$5 = 1,
    COMPARE_UNORDERED_FLAG$3 = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */

function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  } // Check that cyclic values are equal.


  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);

  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }

  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : undefined;
  stack.set(array, other);
  stack.set(other, array); // Ignore non-index properties.

  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }

    if (compared !== undefined) {
      if (compared) {
        continue;
      }

      result = false;
      break;
    } // Recursively compare arrays (susceptible to call stack limits).


    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }

  stack['delete'](array);
  stack['delete'](other);
  return result;
}

var _equalArrays = equalArrays$2;

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */

function mapToArray$1(map) {
  var index = -1,
      result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

var _mapToArray = mapToArray$1;

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */

function setToArray$1(set) {
  var index = -1,
      result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

var _setToArray = setToArray$1;

var _Symbol = _baseGetTag._Symbol,
    Uint8Array = _Uint8Array._Uint8Array,
    eq = eq$1.eq_1,
    equalArrays$1 = _equalArrays,
    mapToArray = _mapToArray,
    setToArray = _setToArray;
/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$4 = 1,
    COMPARE_UNORDERED_FLAG$2 = 2;
/** `Object#toString` result references. */

var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';
/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }

      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }

      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked) {
        return stacked == other;
      }

      bitmask |= COMPARE_UNORDERED_FLAG$2; // Recursively compare objects (susceptible to call stack limits).

      stack.set(object, other);
      var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }

  }

  return false;
}

var _equalByTag = equalByTag$1;

var getAllKeys = _Uint8Array._getAllKeys;
/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$3 = 1;
/** Used for built-in method references. */

var objectProto$1 = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }

  var index = objLength;

  while (index--) {
    var key = objProps[index];

    if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
      return false;
    }
  } // Check that cyclic values are equal.


  var objStacked = stack.get(object);
  var othStacked = stack.get(other);

  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }

  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;

  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    } // Recursively compare objects (susceptible to call stack limits).


    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }

    skipCtor || (skipCtor = key == 'constructor');
  }

  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }

  stack['delete'](object);
  stack['delete'](other);
  return result;
}

var _equalObjects = equalObjects$1;

var Stack$1 = _Uint8Array._Stack,
    equalArrays = _equalArrays,
    equalByTag = _equalByTag,
    equalObjects = _equalObjects,
    getTag = _getTag._getTag,
    isArray$1 = isArray$2.isArray_1,
    isBuffer = _getTag.isBuffer.exports,
    isTypedArray = _getTag.isTypedArray_1;
/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$2 = 1;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$1(object),
      othIsArr = isArray$1(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }

    objIsArr = true;
    objIsObj = false;
  }

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$1());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }

  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$1());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }

  if (!isSameTag) {
    return false;
  }

  stack || (stack = new Stack$1());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

var _baseIsEqualDeep = baseIsEqualDeep$1;

var baseIsEqualDeep = _baseIsEqualDeep,
    isObjectLike = isObjectLike$1.isObjectLike_1;
/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */

function baseIsEqual$2(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }

  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }

  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$2, stack);
}

var _baseIsEqual = baseIsEqual$2;

var Stack = _Uint8Array._Stack,
    baseIsEqual$1 = _baseIsEqual;
/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG$1 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;
/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */

function baseIsMatch$1(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }

  object = Object(object);

  while (index--) {
    var data = matchData[index];

    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }

  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();

      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }

      if (!(result === undefined ? baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }

  return true;
}

var _baseIsMatch = baseIsMatch$1;

var isObject = isObject$1.isObject_1;
/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */

function isStrictComparable$2(value) {
  return value === value && !isObject(value);
}

var _isStrictComparable = isStrictComparable$2;

var isStrictComparable$1 = _isStrictComparable,
    keys = _Uint8Array.keys_1;
/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */

function getMatchData$1(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];
    result[length] = [key, value, isStrictComparable$1(value)];
  }

  return result;
}

var _getMatchData = getMatchData$1;

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

function matchesStrictComparable$2(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }

    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

var _matchesStrictComparable = matchesStrictComparable$2;

var baseIsMatch = _baseIsMatch,
    getMatchData = _getMatchData,
    matchesStrictComparable$1 = _matchesStrictComparable;
/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatches$1(source) {
  var matchData = getMatchData(source);

  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
  }

  return function (object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

var _baseMatches = baseMatches$1;

var baseIsEqual = _baseIsEqual,
    get = get$1.get_1,
    hasIn = hasIn$1.hasIn_1,
    isKey$1 = _baseGet._isKey,
    isStrictComparable = _isStrictComparable,
    matchesStrictComparable = _matchesStrictComparable,
    toKey$1 = _baseGet._toKey;
/** Used to compose bitmasks for value comparisons. */

var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatchesProperty$1(path, srcValue) {
  if (isKey$1(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey$1(path), srcValue);
  }

  return function (object) {
    var objValue = get(object, path);
    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

var _baseMatchesProperty = baseMatchesProperty$1;

var baseGet = _baseGet._baseGet;
/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */

function basePropertyDeep$1(path) {
  return function (object) {
    return baseGet(object, path);
  };
}

var _basePropertyDeep = basePropertyDeep$1;

var baseProperty = _baseProperty._baseProperty,
    basePropertyDeep = _basePropertyDeep,
    isKey = _baseGet._isKey,
    toKey = _baseGet._toKey;
/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */

function property$1(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

var property_1 = property$1;

var baseMatches = _baseMatches,
    baseMatchesProperty = _baseMatchesProperty,
    identity = identity$1.identity_1,
    isArray = isArray$2.isArray_1,
    property = property_1;
/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */

function baseIteratee$1(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }

  if (value == null) {
    return identity;
  }

  if (_typeof._typeof(value) == 'object') {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }

  return property(value);
}

var _baseIteratee = baseIteratee$1;

var baseFindIndex = _cacheHas._baseFindIndex,
    baseIteratee = _baseIteratee,
    toInteger = toInteger$1.toInteger_1;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max;
/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */

function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;

  if (!length) {
    return -1;
  }

  var index = fromIndex == null ? 0 : toInteger(fromIndex);

  if (index < 0) {
    index = nativeMax(length + index, 0);
  }

  return baseFindIndex(array, baseIteratee(predicate), index);
}

var findIndex_1 = findIndex;

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { defineProperty._defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var urlCreator = window.webkitURL || window.URL;

var Upload = function Upload(props, ref) {
  var _useDefaultValue = upload_hooks_useDefaultValue["default"](props, []),
      disabled = _useDefaultValue.disabled,
      multiple = _useDefaultValue.multiple,
      accept = _useDefaultValue.accept,
      draggable = _useDefaultValue.draggable,
      placeholder = _useDefaultValue.placeholder,
      _useDefaultValue$max = _useDefaultValue.max,
      max = _useDefaultValue$max === void 0 ? 0 : _useDefaultValue$max,
      _useDefaultValue$name = _useDefaultValue.name,
      name = _useDefaultValue$name === void 0 ? "file" : _useDefaultValue$name,
      _useDefaultValue$them = _useDefaultValue.theme,
      theme = _useDefaultValue$them === void 0 ? "file" : _useDefaultValue$them,
      _useDefaultValue$show = _useDefaultValue.showUploadProgress,
      showUploadProgress = _useDefaultValue$show === void 0 ? true : _useDefaultValue$show,
      action = _useDefaultValue.action,
      tips = _useDefaultValue.tips,
      format = _useDefaultValue.format,
      data = _useDefaultValue.data,
      headers = _useDefaultValue.headers,
      withCredentials = _useDefaultValue.withCredentials,
      _useDefaultValue$auto = _useDefaultValue.autoUpload,
      autoUpload = _useDefaultValue$auto === void 0 ? true : _useDefaultValue$auto,
      formatResponse = _useDefaultValue.formatResponse,
      beforeUpload = _useDefaultValue.beforeUpload,
      onProgress = _useDefaultValue.onProgress,
      onChange = _useDefaultValue.onChange,
      onSuccess = _useDefaultValue.onSuccess,
      onFail = _useDefaultValue.onFail,
      onRemove = _useDefaultValue.onRemove,
      onDragenter = _useDefaultValue.onDragenter,
      onDragleave = _useDefaultValue.onDragleave,
      requestMethod = _useDefaultValue.requestMethod,
      _useDefaultValue$file = _useDefaultValue.files,
      fileList = _useDefaultValue$file === void 0 ? [] : _useDefaultValue$file,
      customDraggerRender = _useDefaultValue.customDraggerRender,
      children = _useDefaultValue.children;

  var _useConfig = _util_useConfig["default"](),
      classPrefix = _useConfig.classPrefix;

  var uploadRef = React.useRef();

  var _useState = React.useState(""),
      _useState2 = slicedToArray._slicedToArray(_useState, 2),
      errorMsg = _useState2[0],
      setErrorMsg = _useState2[1];

  var _useState3 = React.useState(false),
      _useState4 = slicedToArray._slicedToArray(_useState3, 2),
      uploading = _useState4[0],
      setUploading = _useState4[1];

  var _useState5 = React.useState([]),
      _useState6 = slicedToArray._slicedToArray(_useState5, 2),
      toUploadFiles = _useState6[0],
      setToUploadFiles = _useState6[1];

  var showImgDialog = ["image", "image-flow", "custom"].includes(theme);

  var _useState7 = React.useState(false),
      _useState8 = slicedToArray._slicedToArray(_useState7, 2),
      showImg = _useState8[0],
      setShowImg = _useState8[1];

  var _useState9 = React.useState(""),
      _useState10 = slicedToArray._slicedToArray(_useState9, 2),
      imgURL = _useState10[0],
      setImgURL = _useState10[1];

  var closePreview = React.useCallback(function () {
    setShowImg(false);
    setImgURL("");
  }, []);
  var handlePreviewImg = React.useCallback(function (event, file) {
    if (!file.url) throw new Error("Error file");
    setImgURL(file.url);
    setShowImg(true);
  }, []);

  var triggerUpload = function triggerUpload() {
    if (disabled) return;
    uploadRef === null || uploadRef === void 0 ? void 0 : uploadRef.current.click();
  };

  var getLimitedFiles = function getLimitedFiles() {
    var files = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var isSingleMode = upload_util.isSingleFile(multiple, theme);
    var mergedLen = files.length + fileList.length;

    if (isSingleMode) {
      return files.splice(0, 1);
    }

    if (max > 0) {
      var limitedFiles = mergedLen > max ? files.slice(0, max - fileList.length) : files;
      return fileList.concat(limitedFiles);
    }

    return fileList.concat(files);
  };

  var onError = React.useCallback(function (options) {
    var _res;

    var event = options.event,
        file = options.file,
        response = options.response;
    file.status = "fail";
    var res = response;

    if (typeof formatResponse === "function") {
      res = formatResponse(response, {
        file: file
      });
    }

    setErrorMsg(((_res = res) === null || _res === void 0 ? void 0 : _res.error) || "\u4E0A\u4F20\u5931\u8D25");
    var context = {
      e: event,
      file: file
    };
    var nextFileList = upload_util.updateFileList(file, fileList);
    onChange === null || onChange === void 0 ? void 0 : onChange(nextFileList, {
      trigger: "upload fail"
    });
    onFail === null || onFail === void 0 ? void 0 : onFail(context);
  }, [fileList, formatResponse, onChange, onFail]);
  var singleDraggable = React.useMemo(function () {
    return !multiple && draggable && ["file", "file-input", "image", "custom"].includes(theme);
  }, [draggable, multiple, theme]);

  var handleSingleRemove = function handleSingleRemove(e) {
    var changeCtx = {
      trigger: "remove"
    };
    setErrorMsg("");
    onChange === null || onChange === void 0 ? void 0 : onChange([], changeCtx);
    onRemove === null || onRemove === void 0 ? void 0 : onRemove({
      e: e
    });
  };

  var handleSuccess = React.useCallback(function (_ref) {
    var e = _ref.e,
        tmpFile = _ref.file,
        response = _ref.response;
    var file = tmpFile;
    file.status = "success";
    file.url = response.url || file.url;
    var context = {
      e: e,
      response: response,
      trigger: "upload-success"
    };
    var nextFileList = upload_util.updateFileList(file, fileList);
    var sContext = {
      file: file,
      fileList: nextFileList,
      e: e,
      response: response
    };
    setToUploadFiles(function (toUploadFiles2) {
      return toUploadFiles2.filter(function (toUploadFile) {
        return toUploadFile.name !== file.name;
      });
    });
    onChange === null || onChange === void 0 ? void 0 : onChange(nextFileList, context);
    onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(sContext);
  }, [fileList, onChange, onSuccess]);
  var handleProgress = React.useCallback(function (_ref2) {
    var e = _ref2.e,
        file = _ref2.file,
        percent = _ref2.percent,
        _ref2$type = _ref2.type,
        type = _ref2$type === void 0 ? "mock" : _ref2$type;

    var tmpFile = _objectSpread({}, file);

    tmpFile.percent = percent;
    var progressCtx = {
      percent: percent,
      e: e,
      file: tmpFile,
      type: type
    };
    var nextFileList = upload_util.updateFileList(tmpFile, fileList);
    onChange === null || onChange === void 0 ? void 0 : onChange(nextFileList, {
      trigger: "progress"
    });
    onProgress === null || onProgress === void 0 ? void 0 : onProgress(progressCtx);
  }, [fileList, onChange, onProgress]);
  var handleRequestMethod = React.useCallback(function (file) {
    if (typeof requestMethod !== "function") {
      console.warn("TDesign Upload Warn: `requestMethod` must be a function.");
      return;
    }

    requestMethod(file).then(function (res) {
      if (!handleRequestMethodResponse(res)) return;

      if (res.status === "success") {
        return handleSuccess({
          file: file,
          response: res.response
        });
      }

      if (res.status === "fail") {
        var r = res.response || {};
        onError({
          file: file,
          response: _objectSpread(_objectSpread({}, r), {}, {
            error: res.error
          })
        });
      }
    });
  }, [handleSuccess, onError, requestMethod]);
  var upload = React.useCallback( /*#__PURE__*/function () {
    var _ref3 = index._asyncToGenerator( /*#__PURE__*/index.regenerator.mark(function _callee(uploadFile) {
      var file;
      return index.regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              file = _objectSpread({}, uploadFile);

              if (!(file.status !== "waiting")) {
                _context.next = 3;
                break;
              }

              return _context.abrupt("return");

            case 3:
              if (!(!action && !requestMethod)) {
                _context.next = 6;
                break;
              }

              console.error("TDesign Upload Error: action or requestMethod is required.");
              return _context.abrupt("return");

            case 6:
              setErrorMsg("");
              file.status = "progress";

              if (!requestMethod) {
                _context.next = 10;
                break;
              }

              return _context.abrupt("return", handleRequestMethod(file));

            case 10:
              _common_js_upload_xhr["default"]({
                action: action,
                data: data,
                file: file,
                name: name,
                onError: onError,
                headers: headers,
                withCredentials: withCredentials,
                onProgress: handleProgress,
                onSuccess: handleSuccess
              });

            case 11:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref3.apply(this, arguments);
    };
  }(), [action, data, handleProgress, handleRequestMethod, handleSuccess, headers, name, onError, requestMethod, withCredentials]);

  function handleRequestMethodResponse(res) {
    if (!res) {
      console.error("TDesign Upload Error: `requestMethodResponse` is required.");
      return false;
    }

    if (!res.status) {
      console.error("TDesign Upload Error: `requestMethodResponse.status` is missing, which value is `success` or `fail`");
      return false;
    }

    if (!["success", "fail"].includes(res.status)) {
      console.error("TDesign Upload Error: `requestMethodResponse.status` must be `success` or `fail`");
      return false;
    }

    if (res.status === "success" && (!res.response || !res.response.url)) {
      console.warn("TDesign Upload Warn: `requestMethodResponse.response.url` is required, when `status` is `success`");
    }

    return true;
  }

  var formatFiles = function formatFiles() {
    var files = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return files.map(function (fileRaw) {
      var file = typeof format === "function" ? format(fileRaw) : fileRaw;

      var uploadFile = _objectSpread({
        raw: fileRaw,
        lastModified: fileRaw.lastModified,
        name: fileRaw.name,
        size: fileRaw.size,
        type: fileRaw.type,
        percent: 0,
        status: "waiting"
      }, file);

      uploadFile.url = urlCreator.createObjectURL(fileRaw);
      return uploadFile;
    });
  };

  var handleBeforeUpload = function handleBeforeUpload(file) {
    if (typeof beforeUpload === "function") {
      var r = beforeUpload(file);
      if (r instanceof Promise) return r;
      return new Promise(function (resolve) {
        return resolve(r);
      });
    }

    return new Promise(function (resolve) {
      return resolve(true);
    });
  };

  var uploadFiles = function uploadFiles() {
    var length = fileList.length;
    var count = 0;
    var newFileList = [];
    fileList.forEach(function (uploadFile) {
      handleBeforeUpload(uploadFile).then(function (canUpload) {
        count += 1;

        if (canUpload) {
          newFileList.push(uploadFile);

          if (autoUpload) {
            upload(uploadFile);
          }
        }

        if (count === length) {
          setToUploadFiles(toConsumableArray._toConsumableArray( /* @__PURE__ */new Set([].concat(toConsumableArray._toConsumableArray(toUploadFiles), newFileList))));
          onChange === null || onChange === void 0 ? void 0 : onChange(newFileList, {
            trigger: "remove"
          });
        }
      });
    });
  };

  var generateUploadFiles = function generateUploadFiles(files) {
    var uploadList = formatFiles(Array.from(files));
    return getLimitedFiles(uploadList);
  };

  var handleChange = function handleChange(event) {
    if (disabled) return;
    var files = event.target.files;
    var uploadFiles2 = generateUploadFiles(files);
    setUploading(true);
    uploadRef.current.value = "";
    onChange === null || onChange === void 0 ? void 0 : onChange(uploadFiles2, {
      trigger: "upload"
    });
  };

  var handleDragChange = function handleDragChange(files) {
    if (disabled) return;
    var uploadFiles2 = generateUploadFiles(files);
    setUploading(true);
    onChange === null || onChange === void 0 ? void 0 : onChange(uploadFiles2, {
      trigger: "drag"
    });
  };

  var handleDragenter = React.useCallback(function (e) {
    if (disabled) return;
    onDragenter === null || onDragenter === void 0 ? void 0 : onDragenter({
      e: e
    });
  }, [disabled, onDragenter]);
  var handleDragleave = React.useCallback(function (e) {
    if (disabled) return;
    onDragleave === null || onDragleave === void 0 ? void 0 : onDragleave({
      e: e
    });
  }, [disabled, onDragleave]);
  var cancelUpload = React.useCallback(function () {
    if (!fileList[0]) {
      urlCreator === null || urlCreator === void 0 ? void 0 : urlCreator.revokeObjectURL(fileList[0].url);
    }

    uploadRef.current.value = "";
  }, [fileList]);
  var showUploadList = React.useMemo(function () {
    return multiple && ["file-flow", "image-flow"].includes(theme);
  }, [theme, multiple]);
  var showErrorMsg = React.useMemo(function () {
    return !showUploadList && !!errorMsg;
  }, [errorMsg, showUploadList]);
  var showTips = React.useMemo(function () {
    if (theme === "file") {
      var noFile = isEmpty.isEmpty_1(fileList);
      return tips && noFile;
    }

    return Boolean(tips);
  }, [fileList, theme, tips]);
  var handleMultipleRemove = React.useCallback(function (options) {
    var files = fileList.concat();
    files.splice(options.index, 1);
    onChange === null || onChange === void 0 ? void 0 : onChange(files, {
      trigger: "remove"
    });
    onRemove === null || onRemove === void 0 ? void 0 : onRemove(options);
  }, [fileList, onChange, onRemove]);
  var handleListRemove = React.useCallback(function (context) {
    var file = context.file;
    var index = findIndex_1(toUploadFiles, function (o) {
      return o.name === file.name;
    });

    if (index >= 0) {
      setToUploadFiles(function (toUploadFiles2) {
        return toUploadFiles2.splice(index, 1);
      });
    } else {
      var index2 = findIndex_1(fileList, function (o) {
        return o.name === file.name;
      });
      handleMultipleRemove({
        e: context.e,
        index: index2
      });
    }
  }, [fileList, handleMultipleRemove, toUploadFiles]);
  var multipleUpload = React.useCallback(function (fileList2) {
    var _iterator = _createForOfIteratorHelper(fileList2),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var file = _step.value;
        upload(file);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }, [upload]);
  React__default["default"].useEffect(function () {
    if (uploading) {
      uploadFiles();
    }
  }, [uploading]);
  React.useMemo(function () {
    var timestamp = Date.now();
    (fileList || []).forEach(function (file, index) {
      if (!file.uid && !Object.isFrozen(file)) {
        file.uid = "td__upload__".concat(timestamp, "_").concat(index, "__");
      }
    });
    var finish = fileList.every(function (file) {
      return upload_util.finishUpload(file.status);
    });
    setUploading(!finish);
  }, [fileList]);
  React__default["default"].useImperativeHandle(ref, function () {
    return {
      upload: uploadRef.current,
      triggerUpload: triggerUpload
    };
  });
  return /* @__PURE__ */React__default["default"].createElement("div", {
    className: "".concat(classPrefix, "-upload")
  }, /* @__PURE__ */React__default["default"].createElement("input", {
    ref: uploadRef,
    type: "file",
    disabled: disabled,
    multiple: multiple,
    accept: accept,
    hidden: true,
    onChange: handleChange
  }), /* @__PURE__ */React__default["default"].createElement(upload_booleanRender["default"], {
    boolExpression: !draggable && theme === "custom"
  }, /* @__PURE__ */React__default["default"].createElement(upload_uploadTrigger["default"], {
    onClick: triggerUpload
  }, children)), /* @__PURE__ */React__default["default"].createElement(upload_booleanRender["default"], {
    boolExpression: !draggable && ["file", "file-input"].includes(theme)
  }, /* @__PURE__ */React__default["default"].createElement(upload_themes_singleFile["default"], {
    file: fileList && fileList[0],
    display: theme,
    placeholder: placeholder,
    onRemove: handleSingleRemove,
    showUploadProgress: showUploadProgress
  }, /* @__PURE__ */React__default["default"].createElement(upload_uploadTrigger["default"], {
    onClick: triggerUpload
  }))), /* @__PURE__ */React__default["default"].createElement(upload_booleanRender["default"], {
    boolExpression: !draggable && theme === "image"
  }, /* @__PURE__ */React__default["default"].createElement(upload_themes_imageCard["default"], {
    multiple: multiple,
    max: max,
    onRemove: handleMultipleRemove,
    onTrigger: triggerUpload,
    files: fileList,
    showUploadProgress: showUploadProgress
  })), /* @__PURE__ */React__default["default"].createElement(upload_booleanRender["default"], {
    boolExpression: singleDraggable
  }, /* @__PURE__ */React__default["default"].createElement(upload_dragger["default"], {
    onChange: handleDragChange,
    onDragenter: handleDragenter,
    onDragleave: handleDragleave,
    file: fileList && fileList[0],
    display: theme,
    customDraggerRender: customDraggerRender,
    onCancel: cancelUpload,
    onRemove: handleSingleRemove,
    onUpload: function onUpload(file) {
      upload(file);
    },
    onTrigger: triggerUpload
  })), /* @__PURE__ */React__default["default"].createElement(upload_booleanRender["default"], {
    boolExpression: showUploadList
  }, /* @__PURE__ */React__default["default"].createElement(upload_themes_flowList_index["default"], {
    files: fileList,
    placeholder: placeholder,
    toUploadFiles: toUploadFiles,
    remove: handleListRemove,
    showUploadProgress: showUploadProgress,
    upload: multipleUpload,
    cancel: cancelUpload,
    display: theme,
    onImgPreview: handlePreviewImg,
    onChange: handleDragChange,
    onDragenter: handleDragenter,
    onDragleave: handleDragleave
  }, /* @__PURE__ */React__default["default"].createElement(upload_uploadTrigger["default"], {
    onClick: triggerUpload
  }))), /* @__PURE__ */React__default["default"].createElement(upload_booleanRender["default"], {
    boolExpression: showImgDialog
  }, /* @__PURE__ */React__default["default"].createElement(dialog_index.Dialog, {
    visible: showImg,
    showOverlay: true,
    width: "auto",
    top: "10%",
    className: "".concat(classPrefix, "-upload__dialog"),
    footer: false,
    header: false,
    onClose: closePreview
  }, /* @__PURE__ */React__default["default"].createElement("p", {
    className: "".concat(classPrefix, "-dialog__dialog-body-img-box")
  }, /* @__PURE__ */React__default["default"].createElement("img", {
    src: imgURL,
    alt: ""
  })))), /* @__PURE__ */React__default["default"].createElement(upload_booleanRender["default"], {
    boolExpression: !errorMsg && showTips
  }, /* @__PURE__ */React__default["default"].createElement(upload_tips["default"], null, tips)), /* @__PURE__ */React__default["default"].createElement(upload_booleanRender["default"], {
    boolExpression: showErrorMsg
  }, /* @__PURE__ */React__default["default"].createElement(upload_tips["default"], {
    type: "error"
  }, errorMsg)));
};

var _Upload = /*#__PURE__*/React.forwardRef(Upload);

exports["default"] = _Upload;
//# sourceMappingURL=upload.js.map
