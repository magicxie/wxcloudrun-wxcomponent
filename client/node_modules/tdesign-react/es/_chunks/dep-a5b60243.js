/**
 * tdesign v0.22.1
 * (c) 2022 tdesign
 * @license MIT
 */

import { _ as _defineProperty } from './dep-9332bbea.js';
import { _ as _slicedToArray } from './dep-93971e86.js';
import { _ as _objectWithoutProperties } from './dep-27d690ce.js';
import React, { useContext, useState, useRef, useEffect } from 'react';
import useResizeObserver from 'use-resize-observer';
import classNames from 'classnames';
import useConfig from '../_util/useConfig.js';
import forwardRefWithStatics from '../_util/forwardRefWithStatics.js';
import useCommonClassName from '../_util/useCommonClassName.js';
import composeRefs from '../_util/composeRefs.js';
import AvatarContext, { AvatarContextProvider } from '../avatar/AvatarContext.js';
import Popup from '../popup/Popup.js';

var _excluded$1 = ["className", "cascading", "collapseAvatar", "max", "placement", "popupProps", "size", "children"];

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var Group = function Group(props) {
  var _classNames;

  var _useConfig = useConfig(),
      classPrefix = _useConfig.classPrefix;

  var preClass = "".concat(classPrefix, "-avatar");

  var className = props.className,
      _props$cascading = props.cascading,
      cascading = _props$cascading === void 0 ? "right-up" : _props$cascading,
      collapseAvatar = props.collapseAvatar,
      max = props.max,
      placement = props.placement,
      popupProps = props.popupProps,
      _props$size = props.size,
      size = _props$size === void 0 ? "medium" : _props$size,
      children = props.children,
      avatarGroupProps = _objectWithoutProperties(props, _excluded$1);

  var childrenList = React.Children.toArray(children);
  var allChildrenList;

  if (childrenList.length > 0) {
    allChildrenList = childrenList.map(function (child, index) {
      return /*#__PURE__*/React.cloneElement(child, _objectSpread$1({
        key: "avatar-group-item-".concat(index)
      }, child.props));
    });
  }

  var groupClass = classNames("".concat(preClass, "-group"), className, (_classNames = {}, _defineProperty(_classNames, "".concat(preClass, "--offset-right"), cascading === "right-up"), _defineProperty(_classNames, "".concat(preClass, "--offset-left"), cascading === "left-up"), _classNames));
  var childrenCount = childrenList.length;

  if (max && childrenCount > max) {
    var showList = allChildrenList.slice(0, max);
    var hiddenList = allChildrenList.slice(max, childrenCount);
    var popupNum = "+".concat(childrenCount - max);

    var popupMergeProps = _objectSpread$1(_objectSpread$1({}, popupProps), {}, {
      placement: placement
    });

    var popupNodes = popupProps ? /* @__PURE__ */React.createElement(Popup, _objectSpread$1({}, popupMergeProps), collapseAvatar ? /* @__PURE__ */React.createElement(_Avatar, {
      size: size
    }, collapseAvatar) : /* @__PURE__ */React.createElement(_Avatar, {
      size: size
    }, popupNum)) : /* @__PURE__ */React.createElement(Popup, {
      key: "avatar-popup-key",
      placement: placement,
      content: hiddenList,
      trigger: "hover",
      showArrow: true
    }, collapseAvatar ? /* @__PURE__ */React.createElement(_Avatar, {
      size: size
    }, collapseAvatar) : /* @__PURE__ */React.createElement(_Avatar, {
      size: size
    }, popupNum));
    showList.push(popupNodes);
    return /* @__PURE__ */React.createElement(AvatarContextProvider, {
      size: size
    }, /* @__PURE__ */React.createElement("div", {
      className: groupClass
    }, showList));
  }

  return /* @__PURE__ */React.createElement(AvatarContextProvider, {
    size: size
  }, /* @__PURE__ */React.createElement("div", _objectSpread$1({
    className: groupClass
  }, avatarGroupProps), allChildrenList));
};

var _excluded = ["alt", "hideOnLoadFailed", "icon", "image", "shape", "size", "onError", "children", "style", "className"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var Avatar = forwardRefWithStatics(function (props, ref) {
  var _classNames;

  var alt = props.alt,
      _props$hideOnLoadFail = props.hideOnLoadFailed,
      hideOnLoadFailed = _props$hideOnLoadFail === void 0 ? false : _props$hideOnLoadFail,
      icon = props.icon,
      image = props.image,
      _props$shape = props.shape,
      shape = _props$shape === void 0 ? "circle" : _props$shape,
      _props$size = props.size,
      avatarSize = _props$size === void 0 ? "default" : _props$size,
      onError = props.onError,
      children = props.children,
      style = props.style,
      className = props.className,
      avatarProps = _objectWithoutProperties(props, _excluded);

  var groupSize = useContext(AvatarContext);

  var _useConfig = useConfig(),
      classPrefix = _useConfig.classPrefix;

  var _useState = useState(1),
      _useState2 = _slicedToArray(_useState, 2),
      scale = _useState2[0],
      setScale = _useState2[1];

  var _useState3 = useState(true),
      _useState4 = _slicedToArray(_useState3, 2),
      isImgExist = _useState4[0],
      setIsImgExist = _useState4[1];

  var avatarRef = useRef(null);
  var avatarChildrenRef = useRef(null);
  var size = avatarSize === "default" ? groupSize : avatarSize;
  var gap = 4;

  var handleScale = function handleScale() {
    if (!avatarChildrenRef.current || !avatarRef.current) {
      return;
    }

    var childrenWidth = avatarChildrenRef.current.offsetWidth;
    var avatarWidth = avatarRef.current.offsetWidth;

    if (childrenWidth !== 0 && avatarWidth !== 0) {
      if (gap * 2 < avatarWidth) {
        setScale(avatarWidth - gap * 2 < childrenWidth ? (avatarWidth - gap * 2) / childrenWidth : 1);
      }
    }
  };

  var _useResizeObserver = useResizeObserver({
    onResize: handleScale
  }),
      observerRef = _useResizeObserver.ref;

  var handleImgLoadError = function handleImgLoadError() {
    onError && onError();
    !hideOnLoadFailed && setIsImgExist(false);
  };

  useEffect(function () {
    setIsImgExist(true);
    setScale(1);
  }, [props.image]);
  useEffect(function () {
    handleScale();
  }, []);

  var _useCommonClassName = useCommonClassName(),
      SIZE = _useCommonClassName.SIZE;

  var numSizeStyle = size && !SIZE[size] ? {
    width: size,
    height: size,
    fontSize: "".concat(Number.parseInt(size, 10) / 2, "px")
  } : {};
  var imageStyle = size && !SIZE[size] ? {
    width: size,
    height: size
  } : {};
  var preClass = "".concat(classPrefix, "-avatar");
  var avatarClass = classNames(preClass, className, (_classNames = {}, _defineProperty(_classNames, SIZE[size], !!SIZE[size]), _defineProperty(_classNames, "".concat(preClass, "--").concat(shape), !!shape), _defineProperty(_classNames, "".concat(preClass, "-icon"), !!icon), _classNames));
  var content;

  if (image && isImgExist) {
    content = /* @__PURE__ */React.createElement("img", {
      src: image,
      alt: alt,
      style: imageStyle,
      onError: handleImgLoadError
    });
  } else if (icon) {
    content = icon;
  } else {
    var childrenStyle = {
      transform: "scale(".concat(scale, ")")
    };
    content = /* @__PURE__ */React.createElement("span", {
      ref: composeRefs(ref, avatarChildrenRef, observerRef),
      style: childrenStyle
    }, children);
  }

  return /* @__PURE__ */React.createElement("div", _objectSpread({
    ref: composeRefs(ref, avatarRef),
    className: avatarClass,
    style: _objectSpread(_objectSpread({}, numSizeStyle), style)
  }, avatarProps), content);
}, {
  Group: Group
});
Avatar.displayName = "Avatar";
var _Avatar = Avatar;

export { Group as G, _Avatar as _ };
//# sourceMappingURL=dep-a5b60243.js.map
