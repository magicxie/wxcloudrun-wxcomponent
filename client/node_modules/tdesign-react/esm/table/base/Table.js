/**
 * tdesign v0.22.1
 * (c) 2022 tdesign
 * @license MIT
 */

import { _ as _defineProperty } from '../../_chunks/dep-9332bbea.js';
import { _ as _slicedToArray } from '../../_chunks/dep-93971e86.js';
import React, { useState, useMemo, useRef, useLayoutEffect } from 'react';
import classNames from 'classnames';
import '../../_chunks/dep-ab1e2688.js';
import { d as debounce_1 } from '../../_chunks/dep-9e88086c.js';
import { i as isObject_1 } from '../../_chunks/dep-a764e3bd.js';
import '../../_chunks/dep-d098d908.js';
import useUpdateEffect from '../../_util/useUpdateEffect.js';
import useConfig from '../../_util/useConfig.js';
import { Pagination } from '../../pagination/index.js';
import { useColumns } from '../hooks/useColumns.js';
import { getScrollDirection, ScrollDirection } from '../util/index.js';
import TableEmptyBody from './TableEmptyBody.js';
import TableHeader from './TableHeader.js';
import TableBody from './TableBody.js';
import TableLoadingBody from './TableLoadingBody.js';
import TableEmptyBody$1 from './TableAsyncLoadingBody.js';
import { TableContextProvider } from './TableContext.js';
import { TableColGroup } from './TableColGroup.js';
import TableFooter from './TableFooter.js';
import { Loading } from '../../loading/index.js';
import '../../_chunks/dep-beac373a.js';
import '../../_chunks/dep-aa2bff1b.js';
import '../../_chunks/dep-156c830d.js';
import '../../_chunks/dep-cac5f189.js';
import '../../_chunks/dep-95c9ff5b.js';
import '../../_chunks/dep-312619d6.js';
import '../../config-provider/ConfigContext.js';
import '../../locale/zh_CN.js';
import '../../pagination/Pagination.js';
import 'tdesign-icons-react';
import '../../_util/noop.js';
import '../../_util/useDefault.js';
import '../../select/index.js';
import '../../select/base/Select.js';
import '../../_chunks/dep-25536592.js';
import '../../_chunks/dep-ae2e9ece.js';
import '../../_chunks/dep-a0400c35.js';
import '../../_chunks/dep-897ce04d.js';
import '../../_chunks/dep-2eff142e.js';
import '../../_chunks/dep-5ace74d6.js';
import '../../_chunks/dep-8309e373.js';
import '../../_chunks/dep-0de37580.js';
import '../../_chunks/dep-44c00646.js';
import '../../_chunks/dep-3853103d.js';
import 'lodash';
import '../../locale/LocalReceiver.js';
import '../../config-provider/index.js';
import '../../config-provider/ConfigProvider.js';
import '../../_chunks/dep-27d690ce.js';
import '../../_util/composeRefs.js';
import '../../_util/useDefaultValue.js';
import '../../_util/forwardRefWithStatics.js';
import 'hoist-non-react-statics';
import '../../select/util/helper.js';
import '../../_chunks/dep-124f91c5.js';
import '../../select/base/OptionGroup.js';
import '../../select/base/Option.js';
import '../../_chunks/dep-d2535fd6.js';
import '../../_util/useRipple.js';
import '../../_util/setStyle.js';
import '../../common/FakeArrow.js';
import '../../input/index.js';
import '../../input/Input.js';
import '../../input/InputGroup.js';
import '../../input/style/index.js';
import '../../input/type.js';
import '../../popup/index.js';
import '../../popup/Popup.js';
import 'react-transition-group';
import 'react-popper';
import '../../_util/usePrevious.js';
import '../../popup/Portal.js';
import 'react-dom';
import '../../popup/hooks/useTriggerProps.js';
import '../../_util/useClickOutside.js';
import '../../popup/hooks/usePopupCssTransition.js';
import '../../popup/style/index.js';
import '../../popup/type.js';
import '../../tag/index.js';
import '../../tag/Tag.js';
import '../../tag/CheckTag.js';
import '../../tag/style/index.js';
import '../../tag/type.js';
import '../../select/base/PopupContent.js';
import '../../select/style/index.js';
import '../../select/type.js';
import '../../loading/loading.js';
import '../../_util/dom.js';
import 'raf';
import '../../_util/easing.js';
import '../../common/Portal.js';
import '../../loading/gradient.js';
import '../../loading/style/index.js';
import '../../loading/type.js';
import '../../loading/plugin.js';
import '../../input-number/index.js';
import '../../input-number/InputNumber.js';
import '../../_util/useCommonClassName.js';
import '../../input-number/StepHandler.js';
import '../../button/index.js';
import '../../button/Button.js';
import '../../button/style/index.js';
import '../../button/type.js';
import '../../input-number/utils/numberUtils.js';
import '../../input-number/style/index.js';
import '../../input-number/type.js';
import '../../pagination/validators.js';
import '../../pagination/style/index.js';
import '../../pagination/type.js';
import './TableCell.js';
import './TableRow.js';

var debounce = debounce_1,
    isObject = isObject_1;
/** Error message constants. */

var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */

function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

var throttle_1 = throttle;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function BaseTable(props) {
  var _classNames, _classNames2;

  var _useConfig = useConfig(),
      classPrefix = _useConfig.classPrefix;

  var _props$bordered = props.bordered,
      bordered = _props$bordered === void 0 ? false : _props$bordered,
      _props$stripe = props.stripe,
      stripe = _props$stripe === void 0 ? false : _props$stripe,
      _props$hover = props.hover,
      hover = _props$hover === void 0 ? false : _props$hover,
      _props$tableLayout = props.tableLayout,
      tableLayout = _props$tableLayout === void 0 ? "fixed" : _props$tableLayout,
      _props$verticalAlign = props.verticalAlign,
      verticalAlign = _props$verticalAlign === void 0 ? "center" : _props$verticalAlign,
      _props$size = props.size,
      size = _props$size === void 0 ? "medium" : _props$size,
      maxHeight = props.maxHeight,
      height = props.height,
      loading = props.loading,
      empty = props.empty,
      _props$data = props.data,
      data = _props$data === void 0 ? [] : _props$data,
      pagination = props.pagination,
      onPageChange = props.onPageChange,
      onScrollX = props.onScrollX,
      onScrollY = props.onScrollY,
      asyncLoading = props.asyncLoading;

  var _useColumns = useColumns(props),
      _useColumns2 = _slicedToArray(_useColumns, 2),
      columns = _useColumns2[0],
      flattenColumns = _useColumns2[1];

  var hasPagination = false;

  var _useState = useState((pagination === null || pagination === void 0 ? void 0 : pagination.current) || (pagination === null || pagination === void 0 ? void 0 : pagination.defaultCurrent) || 1),
      _useState2 = _slicedToArray(_useState, 2),
      innerCurrent = _useState2[0],
      setInnerCurrentPagination = _useState2[1];

  var _useState3 = useState((pagination === null || pagination === void 0 ? void 0 : pagination.pageSize) || (pagination === null || pagination === void 0 ? void 0 : pagination.defaultPageSize) || 10),
      _useState4 = _slicedToArray(_useState3, 2),
      innerPageSize = _useState4[0],
      setInnerPageSize = _useState4[1];

  var isControlledPagination = typeof (pagination === null || pagination === void 0 ? void 0 : pagination.current) !== "undefined" && typeof (pagination === null || pagination === void 0 ? void 0 : pagination.pageSize) !== "undefined";
  useUpdateEffect(function () {
    if (isControlledPagination) {
      setInnerCurrentPagination(pagination === null || pagination === void 0 ? void 0 : pagination.current);
      setInnerPageSize(pagination === null || pagination === void 0 ? void 0 : pagination.pageSize);
    }
  }, [pagination]);

  var onPageSizeChange = function onPageSizeChange(pageSize, pageInfo) {
    var _pagination$onPageSiz;

    pagination === null || pagination === void 0 ? void 0 : (_pagination$onPageSiz = pagination.onPageSizeChange) === null || _pagination$onPageSiz === void 0 ? void 0 : _pagination$onPageSiz.call(pagination, pageSize, pageInfo);
  };

  if (pagination) {
    var total = pagination.total,
        showJumper = pagination.showJumper;
    hasPagination = total > innerPageSize || showJumper && total <= innerPageSize;
  }

  var onInnerPaginationChange = function onInnerPaginationChange(pageInfo) {
    var _pagination$onChange;

    var current = pageInfo.current,
        pageSize = pageInfo.pageSize;
    var newDataSource = data.slice((current - 1) * pageSize, current * pageSize);
    onPageChange === null || onPageChange === void 0 ? void 0 : onPageChange(pageInfo, newDataSource);
    pagination === null || pagination === void 0 ? void 0 : (_pagination$onChange = pagination.onChange) === null || _pagination$onChange === void 0 ? void 0 : _pagination$onChange.call(pagination, pageInfo);

    if (!isControlledPagination) {
      setInnerCurrentPagination(current);
      setInnerPageSize(pageSize);
    }
  };

  var pageData = useMemo(function () {
    if (!hasPagination) return data;

    if (data.length > innerPageSize) {
      var pageStart = (innerCurrent - 1) * innerPageSize;
      var pageEnd = innerCurrent * innerPageSize;
      return data.slice(pageStart, pageEnd);
    }

    return data;
  }, [data, innerPageSize, hasPagination, innerCurrent]);

  var _useState5 = useState(0),
      _useState6 = _slicedToArray(_useState5, 2),
      scrollBarWidth = _useState6[0],
      setScrollBarWidth = _useState6[1];

  var fixedHeader = height > 0 || maxHeight > 0;
  var table = useMemo(function () {
    return {
      fixedHeader: fixedHeader,
      flattenColumns: flattenColumns
    };
  }, [fixedHeader, flattenColumns]);
  var hasFixedColumns = columns.some(function (_ref) {
    var fixed = _ref.fixed;
    return ["left", "right"].includes(fixed);
  });
  var scrollHeaderRef = useRef();
  var scrollBodyRef = useRef();
  var tableRef = useRef();
  var tableContentRef = useRef();

  var _useState7 = useState(false),
      _useState8 = _slicedToArray(_useState7, 2),
      scrollableToLeft = _useState8[0],
      setScrollableToLeft = _useState8[1];

  var _useState9 = useState(false),
      _useState10 = _slicedToArray(_useState9, 2),
      scrollableToRight = _useState10[0],
      setScrollableToRight = _useState10[1];

  var _useState11 = useState(false),
      _useState12 = _slicedToArray(_useState11, 2),
      isHasScrollbar = _useState12[0],
      setIsHasScrollbar = _useState12[1];

  useLayoutEffect(function () {
    if (fixedHeader) {
      setStateScrollBarWidth();
    }
  }, [fixedHeader]);
  useLayoutEffect(function () {
    if (fixedHeader) {
      var limitHeight = height || maxHeight;
      var tableNode = tableRef.current;
      var isHasScrollbarNew = tableNode.offsetHeight > limitHeight;
      setIsHasScrollbar(isHasScrollbarNew);
    }
  }, [pageData]);
  useLayoutEffect(function () {
    var checkScrollableToLeftOrRightDebounce;

    if (hasFixedColumns) {
      checkScrollableToLeftOrRight();
      checkScrollableToLeftOrRightDebounce = debounce_1(checkScrollableToLeftOrRight);
      window.addEventListener("resize", checkScrollableToLeftOrRightDebounce);
    }

    return function () {
      if (hasFixedColumns) {
        window.removeEventListener("resize", checkScrollableToLeftOrRightDebounce);
      }
    };
  }, [hasFixedColumns]);
  var isEmpty = !data.length;

  function renderTableBodyAndTableFooter() {
    if (!!loading) {
      return isEmpty ? /* @__PURE__ */React.createElement(TableFooter, null, /* @__PURE__ */React.createElement(TableEmptyBody, {
        empty: null
      })) : /* @__PURE__ */React.createElement(TableBody, _objectSpread(_objectSpread({}, props), {}, {
        data: pageData
      }));
    }

    if (!!asyncLoading) {
      return /* @__PURE__ */React.createElement(React.Fragment, null, /* @__PURE__ */React.createElement(TableBody, _objectSpread(_objectSpread({}, props), {}, {
        data: pageData
      })), /* @__PURE__ */React.createElement(TableFooter, {
        colspan: columns.length
      }, /* @__PURE__ */React.createElement(TableEmptyBody$1, _objectSpread({}, props))));
    }

    if (isEmpty) {
      return /* @__PURE__ */React.createElement(TableFooter, null, /* @__PURE__ */React.createElement(TableEmptyBody, {
        empty: empty
      }));
    }

    return /* @__PURE__ */React.createElement(TableBody, _objectSpread(_objectSpread({}, props), {}, {
      data: pageData
    }));
  }

  var paginationNode;

  if (hasPagination) {
    paginationNode = /* @__PURE__ */React.createElement("div", {
      className: "".concat(classPrefix, "-table__pagination")
    }, /* @__PURE__ */React.createElement(Pagination, _objectSpread(_objectSpread({}, pagination), {}, {
      current: innerCurrent,
      pageSize: innerPageSize,
      onChange: onInnerPaginationChange,
      onPageSizeChange: onPageSizeChange
    })));
  }

  function getTable(params) {
    var _ref2 = params || {},
        _ref2$enableHeader = _ref2.enableHeader,
        enableHeader = _ref2$enableHeader === void 0 ? true : _ref2$enableHeader,
        _ref2$enableBody = _ref2.enableBody,
        enableBody = _ref2$enableBody === void 0 ? true : _ref2$enableBody;

    return /* @__PURE__ */React.createElement("table", {
      ref: tableRef,
      style: {
        tableLayout: tableLayout,
        height: "100%"
      }
    }, /* @__PURE__ */React.createElement(TableColGroup, {
      columns: columns
    }), enableHeader ? /* @__PURE__ */React.createElement(TableHeader, {
      columns: columns
    }) : null, enableBody ? renderTableBodyAndTableFooter() : null);
  }

  function getTableWithFixedHeader() {
    var style = {};

    if (isHasScrollbar) {
      style = _objectSpread(_objectSpread({}, style), {}, {
        paddingRight: scrollBarWidth
      });
    }

    var fixedHeaderRN = /* @__PURE__ */React.createElement("div", {
      ref: scrollHeaderRef,
      className: "".concat(classPrefix, "-table__header"),
      style: style
    }, getTable({
      enableBody: false
    }));

    var onScroll = function onScroll(e) {
      var scrollLeft = e.target.scrollLeft;
      scrollHeaderRef.current.scrollLeft = scrollLeft;
      handleScroll(e, 10);
    };

    var fixedBodyRN = /* @__PURE__ */React.createElement("div", _objectSpread({
      ref: scrollBodyRef,
      className: "".concat(classPrefix, "-table__body"),
      style: {
        height: isNaN(Number(height)) ? height : "".concat(Number(height), "px"),
        maxHeight: isNaN(Number(maxHeight)) ? maxHeight : "".concat(Number(maxHeight), "px"),
        width: hasFixedColumns ? "100%" : void 0
      }
    }, hasFixedColumns ? {
      onScroll: onScroll
    } : {}), getTable({
      enableHeader: false
    }));
    return /* @__PURE__ */React.createElement(React.Fragment, null, fixedHeaderRN, fixedBodyRN);
  }

  function setStateScrollBarWidth() {
    var scrollDiv = document.createElement("div");
    scrollDiv.style.cssText = "\n      width: 99px;\n      height: 99px;\n      overflow: scroll;\n      position: absolute;\n      top: -9999px;";
    scrollDiv.classList.add("scrollbar");
    document.body.appendChild(scrollDiv);
    var scrollBarWidth2 = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    setScrollBarWidth(scrollBarWidth2);
    document.body.removeChild(scrollDiv);
  }

  function checkScrollableToLeftOrRight() {
    var scrollContainer = fixedHeader ? scrollBodyRef.current : tableContentRef.current;
    var scrollLeft = scrollContainer.scrollLeft,
        scrollWidth = scrollContainer.scrollWidth,
        clientWidth = scrollContainer.clientWidth;
    var scrollableToLeft2 = scrollLeft > 0;
    setScrollableToLeft(scrollableToLeft2);
    var scrollableToRight2 = scrollLeft + clientWidth < scrollWidth;
    setScrollableToRight(scrollableToRight2);
  }

  function handleScroll(e) {
    var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
    var _e$target = e.target,
        scrollLeft = _e$target.scrollLeft,
        scrollTop = _e$target.scrollTop;
    var scrollFn = throttle_1(function () {
      checkScrollableToLeftOrRight();
      var direction = getScrollDirection(scrollLeft, scrollTop);

      if (direction !== ScrollDirection.UNKNOWN) {
        var scrollListenerFn = direction === ScrollDirection.X ? onScrollX : onScrollY;
        var scrollParams = {
          e: e
        };
        scrollListenerFn === null || scrollListenerFn === void 0 ? void 0 : scrollListenerFn(scrollParams);
      }
    }, duration);
    scrollFn();
  }

  return /* @__PURE__ */React.createElement("div", {
    className: classNames("".concat(classPrefix, "-table"), (_classNames = {}, _defineProperty(_classNames, "".concat(classPrefix, "-table--striped"), stripe), _defineProperty(_classNames, "".concat(classPrefix, "-table--bordered"), bordered), _defineProperty(_classNames, "".concat(classPrefix, "-size-l"), size === "large"), _defineProperty(_classNames, "".concat(classPrefix, "-size-s"), size === "small"), _defineProperty(_classNames, "".concat(classPrefix, "-table--hoverable"), hover), _defineProperty(_classNames, "".concat(classPrefix, "-table--align-").concat(verticalAlign), verticalAlign), _defineProperty(_classNames, "".concat(classPrefix, "-table__header--fixed"), fixedHeader), _defineProperty(_classNames, "".concat(classPrefix, "-table__cell--fixed ").concat(classPrefix, "-table--has-fixed"), hasFixedColumns), _classNames))
  }, /* @__PURE__ */React.createElement(TableContextProvider, {
    value: table
  }, /* @__PURE__ */React.createElement(Loading, {
    loading: !!loading,
    showOverlay: true,
    indicator: loading === true,
    text: typeof loading !== "boolean" ? /* @__PURE__ */React.createElement(TableLoadingBody, _objectSpread({}, props)) : null
  }, /* @__PURE__ */React.createElement("div", _objectSpread({
    ref: tableContentRef,
    className: classNames("".concat(classPrefix, "-table__content"), (_classNames2 = {}, _defineProperty(_classNames2, "".concat(classPrefix, "-table__content--scrollable-to-right"), scrollableToRight), _defineProperty(_classNames2, "".concat(classPrefix, "-table__content--scrollable-to-left"), scrollableToLeft), _classNames2)),
    style: {
      overflow: "auto"
    }
  }, hasFixedColumns ? {
    onScroll: handleScroll
  } : {}), !fixedHeader ? getTable() : getTableWithFixedHeader())), hasPagination && paginationNode));
}

export { BaseTable as default };
//# sourceMappingURL=Table.js.map
