/**
 * tdesign v0.22.1
 * (c) 2022 tdesign
 * @license MIT
 */

import { _ as _defineProperty } from '../../_chunks/dep-9332bbea.js';
import { _ as _slicedToArray } from '../../_chunks/dep-93971e86.js';
import React, { useState, useRef, useMemo, useEffect, useCallback } from 'react';
import classNames from 'classnames';
import dayjs from 'dayjs';
import { d as debounce_1 } from '../../_chunks/dep-9e88086c.js';
import { p as padStart_1 } from '../../_chunks/dep-8dc257e5.js';
import '../../_chunks/dep-ab1e2688.js';
import { _ as _isIterateeCall } from '../../_chunks/dep-6bae5139.js';
import { a as toFinite_1 } from '../../_chunks/dep-028895a6.js';
import useConfig from '../../_util/useConfig.js';
import noop from '../../_util/noop.js';
import { EPickerCols } from '../interfaces.js';
import { useTimePickerTextConfig, MERIDIEM_LIST, AM, PM } from '../consts.js';
import '../../_chunks/dep-beac373a.js';
import '../../_chunks/dep-a764e3bd.js';
import '../../_chunks/dep-156c830d.js';
import '../../_chunks/dep-d098d908.js';
import '../../_chunks/dep-aa2bff1b.js';
import '../../_chunks/dep-cac5f189.js';
import '../../_chunks/dep-95c9ff5b.js';
import '../../_chunks/dep-312619d6.js';
import '../../_chunks/dep-44c00646.js';
import '../../_chunks/dep-897ce04d.js';
import '../../_chunks/dep-2eff142e.js';
import '../../_chunks/dep-304ab091.js';
import '../../_chunks/dep-ea69dcf8.js';
import '../../_chunks/dep-8bccb9b0.js';
import '../../_chunks/dep-0de37580.js';
import '../../_chunks/dep-b8263a1c.js';
import '../../_chunks/dep-25536592.js';
import '../../_chunks/dep-8309e373.js';
import '../../_chunks/dep-14692160.js';
import '../../_chunks/dep-f88db21e.js';
import '../../config-provider/ConfigContext.js';
import '../../locale/zh_CN.js';
import '../../locale/LocalReceiver.js';
import '../../config-provider/index.js';
import '../../config-provider/ConfigProvider.js';
import '../../_chunks/dep-27d690ce.js';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax = Math.max;
/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */

function baseRange$1(start, end, step, fromRight) {
  var index = -1,
      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
      result = Array(length);

  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }

  return result;
}

var _baseRange = baseRange$1;

var baseRange = _baseRange,
    isIterateeCall = _isIterateeCall,
    toFinite = toFinite_1;
/**
 * Creates a `_.range` or `_.rangeRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */

function createRange$1(fromRight) {
  return function (start, end, step) {
    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
      end = step = undefined;
    } // Ensure the sign of `-0` is preserved.


    start = toFinite(start);

    if (end === undefined) {
      end = start;
      start = 0;
    } else {
      end = toFinite(end);
    }

    step = step === undefined ? start < end ? 1 : -1 : toFinite(step);
    return baseRange(start, end, step, fromRight);
  };
}

var _createRange = createRange$1;

var createRange = _createRange;
/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
 * `start` is specified without an `end` or `step`. If `end` is not specified,
 * it's set to `start` with `start` then set to `0`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.rangeRight
 * @example
 *
 * _.range(4);
 * // => [0, 1, 2, 3]
 *
 * _.range(-4);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 5);
 * // => [1, 2, 3, 4]
 *
 * _.range(0, 20, 5);
 * // => [0, 5, 10, 15]
 *
 * _.range(0, -4, -1);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.range(0);
 * // => []
 */

var range = createRange();
var range_1 = range;

var timeArr = [EPickerCols.hour, EPickerCols.minute, EPickerCols.second];

var SinglePanel = function SinglePanel(props) {
  var steps = props.steps,
      format = props.format,
      _props$onChange = props.onChange,
      onChange = _props$onChange === void 0 ? noop : _props$onChange,
      value = props.value,
      _props$hideDisabledTi = props.hideDisabledTime,
      hideDisabledTime = _props$hideDisabledTi === void 0 ? true : _props$hideDisabledTi,
      disableTime = props.disableTime;

  var _useConfig = useConfig(),
      classPrefix = _useConfig.classPrefix;

  var TEXT_CONFIG = useTimePickerTextConfig();
  var panelClassName = "".concat(classPrefix, "-time-picker__panel");

  var _useState = useState([]),
      _useState2 = _slicedToArray(_useState, 2),
      cols = _useState2[0],
      setCols = _useState2[1];

  var colsRef = useRef([]);
  var maskRef = useRef(null);
  var dayjsValue = useMemo(function () {
    var isStepsSet = !!steps.filter(function (v) {
      return v > 1;
    }).length;

    if (value) {
      return dayjs(value, format);
    }

    if (isStepsSet) {
      return dayjs().hour(0).minute(0).second(0);
    }

    return dayjs();
  }, [value, format, steps]);
  useEffect(function () {
    colsRef.current = colsRef.current.slice(0, cols.length);
  }, [cols]);
  useEffect(function () {
    var match = format.match(/(a\s+|A\s+)?(h+|H+)?:?(m+)?:?(s+)?(\s+a|\s+A)?/);

    var _match = _slicedToArray(match, 6),
        startCol = _match[1],
        hourCol = _match[2],
        minuteCol = _match[3],
        secondCol = _match[4],
        endCol = _match[5];

    var meridiem = EPickerCols.meridiem,
        hour = EPickerCols.hour,
        minute = EPickerCols.minute,
        second = EPickerCols.second;
    var renderCol = [startCol && meridiem, hourCol && hour, minuteCol && minute, secondCol && second, endCol && meridiem].filter(function (v) {
      return !!v;
    });
    setCols(renderCol);
  }, [format]);
  var getItemHeight = useCallback(function () {
    var _maskRef$current;

    var maskDom = maskRef === null || maskRef === void 0 ? void 0 : (_maskRef$current = maskRef.current) === null || _maskRef$current === void 0 ? void 0 : _maskRef$current.querySelector("div");
    var timeItemTotalHeight = maskDom.offsetHeight + parseInt(getComputedStyle(maskDom).marginTop, 10);
    return timeItemTotalHeight;
  }, []);

  var closestLookup = function closestLookup(availableArr, calcVal, step) {
    if (step <= 1) return calcVal;
    return availableArr.sort(function (a, b) {
      return Math.abs(calcVal + 1 - a) - Math.abs(calcVal + 1 - b);
    })[0];
  };

  var timeItemCanUsed = function timeItemCanUsed(col, el) {
    var colIdx = timeArr.indexOf(col);

    if (colIdx !== -1) {
      var params = [dayjsValue.hour(), dayjsValue.minute(), dayjsValue.second()];
      params[colIdx] = el;
      return !(disableTime && disableTime !== null && disableTime !== void 0 && disableTime.apply(void 0, params));
    }

    return true;
  };

  var getColList = useCallback(function (col) {
    var count = 0;

    if (timeArr.includes(col)) {
      var colIdx = timeArr.indexOf(col);
      var colStep = steps[colIdx];

      if (col === EPickerCols.hour) {
        count = /[h]{1}/.test(format) ? 11 : 23;
      } else {
        count = 59;
      }

      var colList = range_1(0, count + 1, Number(colStep)).map(function (v) {
        return padStart_1(String(v), 2, "0");
      }) || [];
      return hideDisabledTime && !!disableTime ? colList.filter(function (t) {
        var params = [dayjsValue.hour(), dayjsValue.minute(), dayjsValue.second()];
        params[colIdx] = Number(t);
        return !(disableTime !== null && disableTime !== void 0 && disableTime.apply(void 0, params));
      }) : colList;
    }

    return MERIDIEM_LIST;
  }, [steps, format, hideDisabledTime, dayjsValue, disableTime]);
  var getScrollDistance = useCallback(function (col, time) {
    if (col === EPickerCols.hour && /[h]{1}/.test(format)) {
      time %= 12;
    }

    var itemIdx = getColList(col).indexOf(padStart_1(String(time), 2, "0"));
    var timeItemTotalHeight = getItemHeight();
    var distance = Math.abs(itemIdx * timeItemTotalHeight + timeItemTotalHeight / 2);
    return distance;
  }, [getItemHeight, getColList, format]);

  var handleScroll = function handleScroll(col, idx, e) {
    var _colsRef$current$idx;

    var val;
    var isScrollUp = e.deltaY < 0;
    var scrollTop = (_colsRef$current$idx = colsRef.current[idx]) === null || _colsRef$current$idx === void 0 ? void 0 : _colsRef$current$idx.scrollTop;
    var colStep = Math.abs(Math.round(scrollTop / getItemHeight() - (isScrollUp && scrollTop >= 1 ? 1 : 0)));

    if (timeArr.includes(col)) {
      var _dayjsValue$col;

      var max = 59;

      if (col === EPickerCols.hour) {
        max = /[h]{1}/.test(format) ? 11 : 23;
      }

      var colIdx = timeArr.indexOf(col);
      var availableArr = range_1(0, max + 1, Number(steps[colIdx]));
      val = closestLookup(availableArr, Number(getColList(col)[Math.min(colStep, max, availableArr.length - 1)]), Number(steps[colIdx]));

      if (col === EPickerCols.hour && cols.includes(EPickerCols.meridiem) && dayjsValue.hour() > 12) {
        val = Number(val) + 12;
      }

      if (timeItemCanUsed(col, val)) onChange((_dayjsValue$col = dayjsValue[col]) === null || _dayjsValue$col === void 0 ? void 0 : _dayjsValue$col.call(dayjsValue, val).format(format));
    } else {
      var meridiem = MERIDIEM_LIST[Math.min(colStep, 1)].toLowerCase();
      val = meridiem;
      var currentHour = dayjsValue.hour();

      if (meridiem === AM && currentHour >= 12) {
        onChange(dayjsValue.hour(currentHour - 12).format(format));
      } else if (meridiem === PM && currentHour < 12) {
        onChange(dayjsValue.hour(currentHour + 12).format(format));
      }
    }

    var distance = getScrollDistance(col, val);

    if (distance !== scrollTop) {
      var scroller = colsRef.current[cols.indexOf(col)];
      if (!distance || !scroller || scroller.scrollTop === distance) return;
      scroller.scrollTo({
        top: distance,
        behavior: "smooth"
      });
    }
  };

  var scrollToTime = useCallback(function (col, time, idx) {
    var behavior = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "auto";
    var distance = getScrollDistance(col, time);
    var scroller = colsRef.current[idx];
    if (!distance || !scroller || scroller.scrollTop === distance) return;
    scroller.scrollTo({
      top: distance,
      behavior: behavior
    });
  }, [getScrollDistance]);

  var handleTimeItemClick = function handleTimeItemClick(col, el) {
    if (timeArr.includes(col)) {
      var _dayjsValue$col2, _dayjsValue$col3;

      if (col === EPickerCols.hour && dayjsValue.format("a") === PM && cols.includes(EPickerCols.meridiem)) {
        el = Number(el) + 12;
      }

      value ? onChange((_dayjsValue$col2 = dayjsValue[col]) === null || _dayjsValue$col2 === void 0 ? void 0 : _dayjsValue$col2.call(dayjsValue, el).format(format)) : onChange((_dayjsValue$col3 = dayjsValue[col]) === null || _dayjsValue$col3 === void 0 ? void 0 : _dayjsValue$col3.call(dayjsValue, el).format(format));
    } else {
      var currentHour = dayjsValue.hour();

      if (el === AM && currentHour >= 12) {
        onChange(dayjsValue.hour(currentHour - 12).format(format));
      } else if (el === PM && currentHour < 12) {
        onChange(dayjsValue.hour(currentHour + 12).format(format));
      }
    }
  };

  var updateTimeScrollPos = useCallback(function () {
    var behavior = value ? "smooth" : "auto";
    var isStepsSet = !!steps.filter(function (v) {
      return v > 1;
    }).length;
    cols.forEach(function (col, idx) {
      if (!isStepsSet || isStepsSet && value) {
        var _dayjsValue$col4;

        scrollToTime(col, timeArr.includes(col) ? (_dayjsValue$col4 = dayjsValue[col]) === null || _dayjsValue$col4 === void 0 ? void 0 : _dayjsValue$col4.call(dayjsValue) : dayjsValue.format("a"), idx, behavior);
      } else {
        var _getColList;

        scrollToTime(col, (_getColList = getColList(col)) === null || _getColList === void 0 ? void 0 : _getColList[0], idx, behavior);
      }
    });
  }, [cols, scrollToTime, dayjsValue, value, steps, getColList]);
  useEffect(function () {
    updateTimeScrollPos();
  });
  var isCurrent = useCallback(function (col, colItem) {
    var _dayjsValue$col5;

    var colVal;

    if (col === EPickerCols.meridiem) {
      var currentMeridiem = dayjsValue.format("a");
      return currentMeridiem === colItem;
    }

    colVal = (_dayjsValue$col5 = dayjsValue[col]) === null || _dayjsValue$col5 === void 0 ? void 0 : _dayjsValue$col5.call(dayjsValue);

    if (col === EPickerCols.hour && /[h]{1}/.test(format)) {
      colVal %= 12;
    }

    return colVal === Number(colItem);
  }, [format, dayjsValue]);

  function renderScrollers() {
    return cols.map(function (col, idx) {
      return /* @__PURE__ */React.createElement("ul", {
        key: "".concat(col, "_").concat(idx),
        ref: function ref(el) {
          return colsRef.current[idx] = el;
        },
        className: "".concat(panelClassName, "-body-scroll"),
        onWheel: debounce_1(function (e) {
          return handleScroll(col, idx, e);
        }, 50)
      }, getColList(col).map(function (el) {
        var _classNames;

        return /* @__PURE__ */React.createElement("li", {
          key: el,
          className: classNames("".concat(panelClassName, "-body-scroll-item"), (_classNames = {}, _defineProperty(_classNames, "".concat(classPrefix, "-is-disabled"), !timeItemCanUsed(col, el)), _defineProperty(_classNames, "".concat(classPrefix, "-is-current"), isCurrent(col, el)), _classNames)),
          onClick: function onClick() {
            return handleTimeItemClick(col, el);
          }
        }, timeArr.includes(col) ? el : TEXT_CONFIG[el]);
      }));
    });
  }

  return /* @__PURE__ */React.createElement("div", {
    className: "".concat(panelClassName, "-body")
  }, /* @__PURE__ */React.createElement("div", {
    className: "".concat(panelClassName, "-body-active-mask"),
    ref: maskRef
  }, cols.map(function (col, idx) {
    return /* @__PURE__ */React.createElement("div", {
      key: "".concat(col, "_").concat(idx)
    });
  })), renderScrollers());
};

export { SinglePanel as default };
//# sourceMappingURL=SinglePanel.js.map
