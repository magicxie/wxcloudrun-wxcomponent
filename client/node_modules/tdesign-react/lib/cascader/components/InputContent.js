/**
 * tdesign v0.22.1
 * (c) 2022 tdesign
 * @license MIT
 */

import { _ as _slicedToArray } from '../../_chunks/dep-93971e86.js';
import React, { useState, useMemo, useRef, useEffect } from 'react';
import classNames from 'classnames';
import { i as isFunction_1 } from '../../_chunks/dep-a347fb20.js';
import { CloseCircleFilledIcon } from 'tdesign-icons-react';
import useConfig from '../../_util/useConfig.js';
import useCommonClassName from '../../_util/useCommonClassName.js';
import { Tag } from '../../tag/index.js';
import { Input } from '../../input/index.js';
import FakeArrow from '../../common/FakeArrow.js';
import { getCascaderInnerClasses, getCloseIconClass, getFakeArrowIconClass, getCloseShow, innerContentClickEffect, getSingleContent, getMultipleContent, getPlaceholderShow, outerClickListenerEffect, closeIconClickEffect, handleRemoveTagEffect } from '../utils/inputContent.js';
import '../../_chunks/dep-beac373a.js';
import '../../_chunks/dep-c6576f8f.js';
import '../../_chunks/dep-156c830d.js';
import '../../_chunks/dep-b33ecffe.js';
import '../../config-provider/ConfigContext.js';
import '../../locale/zh_CN.js';
import '../../tag/Tag.js';
import '../../_chunks/dep-9332bbea.js';
import '../../_chunks/dep-27d690ce.js';
import '../../_util/noop.js';
import '../../_util/forwardRefWithStatics.js';
import 'hoist-non-react-statics';
import '../../tag/CheckTag.js';
import '../../_util/useDefault.js';
import '../../input/Input.js';
import '../../input/InputGroup.js';
import '../../_util/useDefaultValue.js';
import '../../_chunks/dep-97e692ae.js';
import '../../_chunks/dep-00169190.js';
import '../../_chunks/dep-17892822.js';
import '../../_chunks/dep-6ca758b4.js';
import '../../_chunks/dep-2924d6ff.js';
import '../../_chunks/dep-beebb45e.js';
import '../../_chunks/dep-8acca302.js';
import '../../_chunks/dep-a554e9c2.js';
import '../../_chunks/dep-060885ed.js';
import '../../_chunks/dep-04305406.js';
import '../../_chunks/dep-aeb2fb38.js';

var SuffixIcon = function SuffixIcon(props) {
  var cascaderContext = props.cascaderContext,
      closeShow = props.closeShow,
      fakeArrowIconClass = props.fakeArrowIconClass,
      closeIconClass = props.closeIconClass;
  var visible = cascaderContext.visible,
      disabled = cascaderContext.disabled,
      size = cascaderContext.size;

  var closeIconClick = function closeIconClick(e) {
    e.stopPropagation();
    closeIconClickEffect(cascaderContext);
  };

  if (closeShow) {
    return /* @__PURE__ */React.createElement(CloseCircleFilledIcon, {
      className: closeIconClass,
      onClick: closeIconClick,
      size: size
    });
  }

  return /* @__PURE__ */React.createElement(FakeArrow, {
    overlayClassName: fakeArrowIconClass,
    isActive: visible,
    disabled: disabled
  });
};

var InnerContent = function InnerContent(props) {
  var cascaderContext = props.cascaderContext,
      listeners = props.listeners,
      placeholder = props.placeholder,
      collapsedItems = props.collapsedItems;

  var _useConfig = useConfig(),
      prefix = _useConfig.classPrefix;

  var multiple = cascaderContext.multiple,
      size = cascaderContext.size,
      disabled = cascaderContext.disabled,
      filterable = cascaderContext.filterable,
      setFilterActive = cascaderContext.setFilterActive,
      visible = cascaderContext.visible,
      inputVal = cascaderContext.inputVal,
      setInputVal = cascaderContext.setInputVal,
      minCollapsedNum = cascaderContext.minCollapsedNum;
  var _onFocus = listeners.onFocus,
      _onBlur = listeners.onBlur,
      onRemove = listeners.onRemove;
  var singleContent = useMemo(function () {
    return getSingleContent(cascaderContext);
  }, [cascaderContext]);
  var multipleContent = useMemo(function () {
    return getMultipleContent(cascaderContext);
  }, [cascaderContext]);

  var renderSelfTag = function renderSelfTag(node, index) {
    return /* @__PURE__ */React.createElement(Tag, {
      closable: !disabled,
      key: index,
      disabled: disabled,
      onClose: function onClose(ctx) {
        ctx.e.stopPropagation();
        handleRemoveTagEffect(cascaderContext, node, onRemove);
      },
      size: size
    }, node.label);
  };

  var generalContent = !multiple ? /* @__PURE__ */React.createElement("span", {
    className: "".concat(prefix, "-cascader__content")
  }, singleContent) : /* @__PURE__ */React.createElement(React.Fragment, null, minCollapsedNum > 0 && multipleContent.length > minCollapsedNum ? /* @__PURE__ */React.createElement(React.Fragment, null, multipleContent.slice(0, minCollapsedNum).map(function (node, index) {
    return renderSelfTag(node, index);
  }), !collapsedItems ? /* @__PURE__ */React.createElement(Tag, {
    size: size,
    disabled: disabled
  }, "+", multipleContent.length - minCollapsedNum) : collapsedItems) : multipleContent.map(function (node, index) {
    return renderSelfTag(node, index);
  }));
  var inputPlaceholder = multiple ? multipleContent.map(function (node) {
    return node.label;
  }).join("\u3001") : singleContent;
  var filterContent = /* @__PURE__ */React.createElement(Input, {
    placeholder: inputPlaceholder || placeholder,
    value: inputVal,
    onChange: function onChange(value) {
      setInputVal(value);
      setFilterActive(!!value);
    },
    autofocus: true,
    onFocus: function onFocus(v, context) {
      return isFunction_1(_onFocus) && _onFocus({
        inputVal: inputVal,
        e: context === null || context === void 0 ? void 0 : context.e
      });
    },
    onBlur: function onBlur(v, context) {
      return isFunction_1(_onBlur) && _onBlur({
        inputVal: inputVal,
        e: context === null || context === void 0 ? void 0 : context.e
      });
    }
  });
  var showFilter = useMemo(function () {
    return filterable && visible;
  }, [filterable, visible]);
  return showFilter ? filterContent : generalContent;
};

var Content = function Content(props) {
  var placeholder = props.placeholder,
      cascaderContext = props.cascaderContext,
      listeners = props.listeners,
      isHover = props.isHover,
      collapsedItems = props.collapsedItems;

  var _useConfig2 = useConfig(),
      prefix = _useConfig2.classPrefix;

  var singleContent = useMemo(function () {
    return getSingleContent(cascaderContext);
  }, [cascaderContext]);
  var multipleContent = useMemo(function () {
    return getMultipleContent(cascaderContext);
  }, [cascaderContext]);
  var showPlaceholder = useMemo(function () {
    return getPlaceholderShow(cascaderContext, singleContent, multipleContent);
  }, [cascaderContext, singleContent, multipleContent]);
  var content = !showPlaceholder ? /* @__PURE__ */React.createElement(InnerContent, {
    isHover: isHover,
    cascaderContext: cascaderContext,
    listeners: listeners,
    collapsedItems: collapsedItems,
    placeholder: placeholder
  }) : /* @__PURE__ */React.createElement("span", {
    className: "".concat(prefix, "-cascader__placeholder")
  }, placeholder || "\u8BF7\u9009\u62E9");
  return content;
};

var InputContent = function InputContent(props) {
  var cascaderContext = props.cascaderContext,
      className = props.className,
      style = props.style,
      placeholder = props.placeholder,
      listeners = props.listeners,
      collapsedItems = props.collapsedItems;

  var _useConfig3 = useConfig(),
      prefix = _useConfig3.classPrefix;

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      isHover = _useState2[0],
      setIsHover = _useState2[1];

  var CLASSNAMES = useCommonClassName();
  var cascaderInnerClasses = useMemo(function () {
    return classNames(getCascaderInnerClasses(prefix, CLASSNAMES, cascaderContext), className);
  }, [prefix, CLASSNAMES, cascaderContext, className]);
  var inputContentRef = useRef();
  useEffect(function () {
    var outerClickListenerFn = function outerClickListenerFn(event) {
      return outerClickListenerEffect(inputContentRef.current, cascaderContext, event);
    };

    document.addEventListener("click", outerClickListenerFn);

    var _inputContentRef$curr = inputContentRef.current.getBoundingClientRect(),
        width = _inputContentRef$curr.width;

    cascaderContext.setInputWidth(width);
    return function () {
      document.removeEventListener("click", outerClickListenerFn);
    };
  }, [cascaderContext]);
  var closeIconClass = useMemo(function () {
    return classNames(getCloseIconClass(prefix, CLASSNAMES, cascaderContext));
  }, [prefix, CLASSNAMES, cascaderContext]);
  var fakeArrowIconClass = useMemo(function () {
    return classNames(getFakeArrowIconClass(prefix, CLASSNAMES, cascaderContext));
  }, [prefix, CLASSNAMES, cascaderContext]);
  var closeShow = useMemo(function () {
    return getCloseShow(isHover, cascaderContext);
  }, [isHover, cascaderContext]);
  return /* @__PURE__ */React.createElement("div", {
    className: cascaderInnerClasses,
    style: style,
    onMouseEnter: function onMouseEnter() {
      setIsHover(true);
    },
    onMouseLeave: function onMouseLeave() {
      setIsHover(false);
    },
    ref: inputContentRef,
    onClick: function onClick(e) {
      e.preventDefault();
      innerContentClickEffect(cascaderContext);
    }
  }, /* @__PURE__ */React.createElement(Content, {
    cascaderContext: cascaderContext,
    isHover: isHover,
    collapsedItems: collapsedItems,
    placeholder: placeholder,
    listeners: listeners
  }), /* @__PURE__ */React.createElement(SuffixIcon, {
    cascaderContext: cascaderContext,
    closeShow: closeShow,
    closeIconClass: closeIconClass,
    fakeArrowIconClass: fakeArrowIconClass,
    listeners: listeners
  }));
};

export { InputContent as default };
//# sourceMappingURL=InputContent.js.map
