/**
 * tdesign v0.22.1
 * (c) 2022 tdesign
 * @license MIT
 */

import { _ as _defineProperty } from '../_chunks/dep-9332bbea.js';
import { _ as _toConsumableArray } from '../_chunks/dep-124f91c5.js';
import { _ as _slicedToArray } from '../_chunks/dep-93971e86.js';
import React, { forwardRef } from 'react';
import ReactDOM from 'react-dom';
import useConfig from '../_util/useConfig.js';
import noop from '../_util/noop.js';
import { NotificationComponent } from './Notification.js';
import '../_chunks/dep-beac373a.js';
import '../config-provider/ConfigContext.js';
import '../locale/zh_CN.js';
import 'tdesign-icons-react';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var seed = 0;
var listMap = /* @__PURE__ */new Map();
var NotificationList = /*#__PURE__*/forwardRef(function (props, ref) {
  var attach = props.attach,
      placement = props.placement,
      zIndex = props.zIndex;

  var _useConfig = useConfig(),
      classPrefix = _useConfig.classPrefix;

  var _React$useReducer = React.useReducer(function (state, action) {
    switch (action.type) {
      case "push":
        return [].concat(_toConsumableArray(state), [action.value]);

      case "remove":
        return state.filter(function (item) {
          return item.key !== action.key;
        }).map(function (item) {
          return item;
        });

      case "removeAll":
        return [];

      default:
        return state;
    }
  }, []),
      _React$useReducer2 = _slicedToArray(_React$useReducer, 2),
      list = _React$useReducer2[0],
      dispatchList = _React$useReducer2[1];

  var notificationMap = React.useMemo(function () {
    return /* @__PURE__ */new Map();
  }, []);
  var remove = React.useCallback(function (key) {
    dispatchList({
      type: "remove",
      key: key
    });
    notificationMap["delete"](key);
  }, [notificationMap]);

  var calOffset = function calOffset(offset) {
    if (!offset) return "16px";
    return isNaN(Number(offset)) ? offset : "".concat(offset, "px");
  };

  var push = React.useCallback(function (theme, options) {
    return new Promise(function (resolve) {
      var key = String(seed += 1);

      var style = function () {
        if (Array.isArray(options.offset)) {
          var _ref = _toConsumableArray(options.offset),
              horizontal = _ref[0],
              vertical = _ref[1];

          var horizontalOffset = calOffset(horizontal);
          var verticalOffset = calOffset(vertical);
          return {
            marginTop: verticalOffset,
            marginBottom: verticalOffset,
            marginLeft: horizontalOffset,
            marginRight: horizontalOffset
          };
        }

        return {
          margin: "16px"
        };
      }();

      notificationMap.set(key, /*#__PURE__*/React.createRef());
      dispatchList({
        type: "push",
        value: _objectSpread(_objectSpread({}, options), {}, {
          key: key,
          theme: theme,
          style: style
        })
      });

      notificationMap.get(key).current.close = function () {
        remove(key);
      };

      resolve(notificationMap.get(key).current);
    });
  }, [notificationMap, remove]);
  var removeAll = React.useCallback(function () {
    dispatchList({
      type: "removeAll"
    });
    notificationMap.clear();
  }, [notificationMap]);
  React.useImperativeHandle(ref, function () {
    return {
      push: push,
      remove: remove,
      removeAll: removeAll
    };
  });
  React.useEffect(function () {
    if (list.length === 0 && notificationMap.size === 0) {
      listMap["delete"](placement);
      ReactDOM.unmountComponentAtNode(attach);
      attach.remove();
    }
  }, [list, attach, placement, notificationMap]);
  return /* @__PURE__ */React.createElement("div", {
    className: "".concat(classPrefix, "-notification__show--").concat(placement),
    style: {
      zIndex: zIndex
    }
  }, list.map(function (props2) {
    var _props2$onDurationEnd = props2.onDurationEnd,
        _onDurationEnd = _props2$onDurationEnd === void 0 ? noop : _props2$onDurationEnd,
        _props2$onCloseBtnCli = props2.onCloseBtnClick,
        _onCloseBtnClick = _props2$onCloseBtnCli === void 0 ? noop : _props2$onCloseBtnCli;

    return /* @__PURE__ */React.createElement(NotificationComponent, _objectSpread(_objectSpread({
      theme: "warning",
      ref: notificationMap.get(props2.key),
      key: props2.key
    }, props2), {}, {
      onDurationEnd: function onDurationEnd() {
        remove(props2.key);

        _onDurationEnd();
      },
      onCloseBtnClick: function onCloseBtnClick(e) {
        remove(props2.key);

        _onCloseBtnClick(e);
      }
    }));
  }));
});
var fetchListInstance = function fetchListInstance(placement, attach, zIndex) {
  return new Promise(function (resolve) {
    if (listMap.has(placement)) {
      resolve(listMap.get(placement));
    } else {
      var hasExec = false;
      ReactDOM.render( /* @__PURE__ */React.createElement(NotificationList, {
        attach: attach,
        placement: placement,
        zIndex: Number(zIndex),
        ref: function ref(instance) {
          if (!hasExec) {
            hasExec = true;
            listMap.set(placement, instance);
            resolve(instance);
          }
        }
      }), attach);
    }
  });
};

export { fetchListInstance, listMap };
//# sourceMappingURL=NotificationList.js.map
